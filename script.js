// Coaster data - will be loaded from CSV files
    let coastersDataLuca = [];
    let coastersDataWouter = [];
    
    const CACHE_VERSION = 'v10-validated';

    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        const data = [];
        
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const values = line.split(',');
            if (values.length >= 5) {
                data.push({
                    naam: (values[1] || '').trim(),
                    park: (values[2] || '').trim(),
                    fabrikant: (values[3] || '').trim(),
                    operatief: parseInt(values[4]) || 0
                });
            }
        }
        
        return data;
    }

    async function loadCoasterData() {
        try {
            const [lucaResponse, wouterResponse] = await Promise.all([
                fetch('Top List Coasters v Luca - List of Coaster.csv'),
                fetch('Top List Coasters Wouter - List of Coaster.csv')
            ]);
            
            if (!lucaResponse.ok || !wouterResponse.ok) {
                throw new Error(`HTTP error! Luca: ${lucaResponse.status}, Wouter: ${wouterResponse.status}`);
            }
            
            const lucaText = await lucaResponse.text();
            const wouterText = await wouterResponse.text();
            
            coastersDataLuca = parseCSV(lucaText);
            coastersDataWouter = parseCSV(wouterText);
            
            console.info(`Loaded: Luca=${coastersDataLuca.length}, Wouter=${coastersDataWouter.length}`);
            initializeApp();
        } catch (error) {
            console.error('Error loading data:', error.message);
            
            // Show a more helpful error message and offer a file-input fallback
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-width:560px;text-align:center;z-index:10000;font-family:sans-serif;';
            errorDiv.innerHTML = `
                <h2 style="color:#e74c3c;margin-bottom:10px;">‚ö†Ô∏è Error loading data</h2>
                <p style="margin:6px 0 12px;">The coaster CSVs could not be loaded with fetch (often when opened via <em>file://</em>).</p>
                <div style="font-size:0.9em;color:#666;margin-bottom:12px;">${escapeHtml(error.message || String(error))}</div>
                <div style="display:flex;gap:8px;justify-content:center;flex-direction:column;align-items:stretch;">
                    <label style="font-weight:700;text-align:left;margin-bottom:6px;">Upload CSV for Luca</label>
                    <input id="fallbackLucaFile" type="file" accept=".csv" />
                    <label style="font-weight:700;text-align:left;margin-bottom:6px;margin-top:8px;">Upload CSV for Wouter</label>
                    <input id="fallbackWouterFile" type="file" accept=".csv" />
                    <button id="fallbackLoadBtn" style="margin-top:10px;padding:10px;border-radius:8px;border:none;background:#3498db;color:#fff;cursor:pointer;font-weight:700;">Load selected files</button>
                    <button id="fallbackCloseBtn" style="margin-top:6px;padding:8px;border-radius:8px;border:1px solid #ddd;background:#fff;color:#333;cursor:pointer;">Close</button>
                </div>
            `;
            document.body.appendChild(errorDiv);

            document.getElementById('fallbackCloseBtn').addEventListener('click', () => { errorDiv.remove(); displayBattle(); });
            document.getElementById('fallbackLoadBtn').addEventListener('click', () => {
                const fL = document.getElementById('fallbackLucaFile');
                const fW = document.getElementById('fallbackWouterFile');
                const fileL = fL && fL.files && fL.files[0] ? fL.files[0] : null;
                const fileW = fW && fW.files && fW.files[0] ? fW.files[0] : null;
                if (!fileL && !fileW) {
                    alert('Select at least one CSV file to load.');
                    return;
                }

                const readFile = (file) => new Promise((res, rej) => {
                    const fr = new FileReader();
                    fr.onload = () => res(fr.result);
                    fr.onerror = rej;
                    fr.readAsText(file);
                });

                Promise.all([
                    fileL ? readFile(fileL) : Promise.resolve(null),
                    fileW ? readFile(fileW) : Promise.resolve(null)
                ]).then(([lText, wText]) => {
                    try {
                        if (lText) coastersDataLuca = parseCSV(lText);
                        if (wText) coastersDataWouter = parseCSV(wText);
                        errorDiv.remove();
                        initializeApp();
                    } catch (e) {
                        alert('Error processing CSV: ' + (e && e.message ? e.message : String(e)));
                    }
                }).catch(e => {
                    alert('Error reading files: ' + (e && e.message ? e.message : String(e)));
                });
            });

            // Also ensure the battle UI updates (hide VS) when CSV loading fails
            try { displayBattle(); } catch (e) { /* ignore */ }
        }
    }

    // Initialize app after data is loaded
    async function initializeApp() {
        // Check if there's a saved user preference
        const savedUser = localStorage.getItem('lastUser');
        if (savedUser && (savedUser === 'luca' || savedUser === 'wouter')) {
            switchUser(savedUser);
        }
        
        // Set header height for mobile sticky tabs
        setHeaderHeight();
        // Post-initialization UI adjustments
        postInitUISetup();
        
        // Load ALL images during loading screen before showing first battle
        await preloadAllCoasterImages();
        
        // Now display the first battle (all images loaded)
        displayBattle();
        
        // Restore the last active tab
        try {
            const savedTab = localStorage.getItem('lastActiveTab');
            const validTabs = ['profile', 'home', 'battle', 'ranking', 'history', 'achievements'];
            if (savedTab && validTabs.includes(savedTab)) {
                switchTab(savedTab);
            }
        } catch (e) { /* ignore */ }
        
        // Match tab heights after initialization
        setTimeout(() => matchTabHeights(), 100);
    }

    // Set header height CSS variable for sticky tabs positioning
    function setHeaderHeight() {
        if (window.innerWidth <= 600) {
            const header = document.querySelector('.header');
            if (header) {
                const headerHeight = header.offsetHeight;
                document.documentElement.style.setProperty('--header-height', headerHeight + 'px');
            }
        }
    }

    // Post-initialization UI setup: safe no-op if features missing
    function postInitUISetup() {
        try {
            // Apply pairing/dev settings to UI if functions exist
            try { applySettingsToUI(); } catch (e) {}
            try { loadDevSettings(); } catch (e) {}
            // Ensure correct battle visibility initially (hide until user selects).
            // If a user is already selected, keep the battle visible.
            try { if (!currentUser) setBattleVisibility(false); } catch (e) {}
            // Sync sim input width
            try { syncSimInputWidth(); } catch (e) {}
            // Hide any close battle overlay that might be showing from previous session
            try {
                const overlay = document.getElementById('closeBattleOverlay');
                if (overlay) {
                    overlay.classList.remove('show');
                    overlay.style.display = 'none';
                }
            } catch (e) {}
            // Cancel any pending close intro animations
            try { cancelCloseIntro(); } catch (e) {}
            
            // Safety mechanism: periodically check and hide overlay if it appears unexpectedly
            setInterval(() => {
                try {
                    const overlay = document.getElementById('closeBattleOverlay');
                    // Only hide if we're not currently in a battle resolution
                    if (overlay && !resolvingBattle && !isProcessingChoice) {
                        if (overlay.classList.contains('show') || overlay.style.display !== 'none') {
                            overlay.classList.remove('show');
                            overlay.style.display = 'none';
                        }
                    }
                } catch (e) { /* ignore */ }
            }, 500);
        } catch (e) {
            // swallow any unexpected errors to avoid breaking initialization
            console.warn('postInitUISetup error', e);
        }
    }

function debounce(fn, wait = 120) {
    let timeoutId = null;
    return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), wait);
    };
}

const $id = (id) => document.getElementById(id);

const CR_STORAGE_COUNTER = 'cr_rareBattleCounter';
const CR_STORAGE_THRESHOLD = 'cr_rareBattleThreshold';

function getCoasterId(c) { return (c && (c.naam || c.name || c.id)) || String(Math.random()); }
function getCoasterName(c) { return (c && (c.naam || c.name)) || 'Coaster'; }

// Global stats for image loading progress (visible in dev menu)
let imageLoadStats = {
    loaded: 0,
    total: 0,
    failed: 0,
    cached: 0
};

// In-memory cache for super-fast image retrieval during rapid battles
const imageMemoryCache = new Map();

// Preload queue for background loading of next battles
let preloadQueue = [];
let isPreloading = false;
let keyboardUsageDetected = false;
const PRELOAD_QUEUE_SIZE_NORMAL = 3;
const PRELOAD_QUEUE_SIZE_FAST = 6;

// Normalize coaster/park name for cache key matching
function normalizeCoasterName(name) {
    if (!name) return '';
    return name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '') // Remove special chars except hyphens
        .replace(/\s+/g, ' ');     // Normalize whitespace
}

function getPlaceholderImage() {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="400" height="250" viewBox="0 0 400 250">
        <defs>
            <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#e5e7eb;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#d1d5db;stop-opacity:1" />
            </linearGradient>
        </defs>
        <rect width="400" height="250" fill="url(#grad)"/>
        <circle cx="200" cy="125" r="40" fill="#9ca3af" opacity="0.3"/>
        <rect x="180" y="100" width="40" height="50" rx="5" fill="#9ca3af" opacity="0.5"/>
    </svg>`;
    // Use encodeURIComponent instead of btoa to handle all characters safely
    return 'data:image/svg+xml,' + encodeURIComponent(svg);
}

async function queryWikidataImage(coasterName, parkName, manufacturer) {
    if (!coasterName) return null;
    
    const escapeSPARQL = (str) => str.replace(/["\\]/g, '\\$&');
    
    // Roller coaster type validation - checks if entity is ANY type of roller coaster
    // Q204832 = roller coaster (parent class), wdt:P279* = subclass of (transitive)
    const coasterTypeFilter = `?item wdt:P31/wdt:P279* wd:Q204832 .`;
    
    // Generate name variants to try (most specific to least specific)
    const nameVariants = [];
    let cleanName = coasterName.trim().replace(/\s+/g, ' ');
    nameVariants.push(cleanName);
    
    if (/\([^)]+\)/.test(cleanName)) {
        const variant = cleanName.replace(/\s*\([^)]+\)\s*/g, ' ').trim();
        if (variant && !nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    if (/ - [A-Z][a-z]+$/.test(cleanName)) {
        const variant = cleanName.replace(/ - [A-Z][a-z]+$/, '').trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // 4. Remove descriptive suffixes after dash (e.g., "Colossos - Kampf der Giganten" ‚Üí "Colossos")
    if (/ - .+$/.test(cleanName) && cleanName.split(' - ').length === 2) {
        const variant = cleanName.split(' - ')[0].trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // 5. Remove subtitle after colon (e.g., "Xpress: Platform 13" ‚Üí "Xpress")
    if (/: .+$/.test(cleanName)) {
        const variant = cleanName.split(':')[0].trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // 6. Remove "Junior" or "Mini" prefix (e.g., "Junior Red Force" ‚Üí "Red Force")
    if (/^(Junior|Mini) /i.test(cleanName)) {
        const variant = cleanName.replace(/^(Junior|Mini) /i, '').trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // 7. Remove Dutch/German articles (e.g., "Joris en de draak" ‚Üí "Joris draak")
    if (/ en de /i.test(cleanName)) {
        const variant = cleanName.replace(/ en de /ig, ' ').trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
        // Also try just first word (e.g., "Joris")
        const firstWord = cleanName.split(' ')[0];
        if (firstWord.length > 3 && !nameVariants.includes(firstWord)) {
            nameVariants.push(firstWord);
        }
    }
    
    // 8. Remove possessive 's (e.g., "Winja's" ‚Üí "Winja")
    if (/'s\b/i.test(cleanName)) {
        const variant = cleanName.replace(/'s\b/ig, '').trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // NEW: 8b. Handle slash alternatives (e.g., "Superman / la Atracci√≥n" ‚Üí "Superman")
    if (/\s*\/\s*/.test(cleanName)) {
        const parts = cleanName.split(/\s*\/\s*/);
        // Add first part
        if (parts[0] && !nameVariants.includes(parts[0].trim())) {
            nameVariants.push(parts[0].trim());
        }
        // Add without slashes
        const noSlash = cleanName.replace(/\s*\/\s*/g, ' ').trim();
        if (!nameVariants.includes(noSlash)) {
            nameVariants.push(noSlash);
        }
    }
    
    // NEW: 8c. Handle "&" and "and" variations
    if (/\s+&\s+/.test(cleanName)) {
        const withAnd = cleanName.replace(/\s+&\s+/g, ' and ');
        if (!nameVariants.includes(withAnd)) nameVariants.push(withAnd);
    }
    if (/\s+and\s+/i.test(cleanName)) {
        const withAmpersand = cleanName.replace(/\s+and\s+/gi, ' & ');
        if (!nameVariants.includes(withAmpersand)) nameVariants.push(withAmpersand);
    }
    
    // NEW: 8d. Handle umlauts and special characters
    const deaccented = cleanName
        .replace(/√§/g, 'a').replace(/√Ñ/g, 'A')
        .replace(/√∂/g, 'o').replace(/√ñ/g, 'O')
        .replace(/√º/g, 'u').replace(/√ú/g, 'U')
        .replace(/√ü/g, 'ss');
    if (deaccented !== cleanName && !nameVariants.includes(deaccented)) {
        nameVariants.push(deaccented);
    }
    
    // 9. Remove generic "Roller Coaster" suffix in various languages
    const genericSuffixes = [
        / Roller Coaster$/i,
        / Rollercoaster$/i,
        / Achterbahn$/i,
        / Coaster$/i
    ];
    for (const suffix of genericSuffixes) {
        if (suffix.test(cleanName)) {
            const variant = cleanName.replace(suffix, '').trim();
            if (variant && !nameVariants.includes(variant)) nameVariants.push(variant);
        }
    }
    
    // 10. Remove "The" prefix (e.g., "The Ride" ‚Üí "Ride")
    if (/^The /i.test(cleanName) && cleanName.split(' ').length > 2) {
        const variant = cleanName.replace(/^The /i, '').trim();
        if (!nameVariants.includes(variant)) nameVariants.push(variant);
    }
    
    // 11. Add space variations for compound names
    if (cleanName.includes(' ') && cleanName.split(' ').length === 2) {
        // Try without space (e.g., "Black Mamba" ‚Üí "BlackMamba")
        const noSpace = cleanName.replace(/ /g, '');
        if (!nameVariants.includes(noSpace)) nameVariants.push(noSpace);
    } else if (!cleanName.includes(' ') && cleanName.length > 6) {
        // Try adding space for common patterns (e.g., "BlackMamba" ‚Üí "Black Mamba")
        const withSpace = cleanName.replace(/([a-z])([A-Z])/g, '$1 $2');
        if (withSpace !== cleanName && !nameVariants.includes(withSpace)) {
            nameVariants.push(withSpace);
        }
    }
    
    // Direct label/alias matching - much more reliable than EntitySearch
    console.log(`  üìù Generated ${nameVariants.length} name variants:`, nameVariants.slice(0, 5).join(', ') + (nameVariants.length > 5 ? '...' : ''));
    
    // Helper to add delay between requests to avoid rate limiting
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    // FAST PATH: Try park-aware search first (most accurate), then fallback to name-only
    // This prevents wrong matches like "iSpeed" when searching for "Speed"
    const variant = nameVariants[0];
    const escapedName = escapeSPARQL(variant);
    const escapedPark = escapeSPARQL(parkName);
    
    if (variant.length < 3) {
        console.log(`‚úó Name too short: "${variant}"`);
        return null;
    }
    
    // STRATEGY 1: Combined park + name query (most accurate, prevents wrong park matches)
    console.log(`  üîç Fast (Park-aware): "${variant}" at "${parkName}"`);
    const parkAwareQuery = `
        SELECT ?item ?image WHERE {
          ?item rdfs:label ?itemLabel .
          FILTER(CONTAINS(LCASE(?itemLabel), LCASE("${escapedName}")))
          ${coasterTypeFilter}
          ?item wdt:P18 ?image .
          
          ?item wdt:P127 ?park .
          ?park rdfs:label ?parkLabel .
          FILTER(CONTAINS(LCASE(?parkLabel), LCASE("${escapedPark}")))
        }
        LIMIT 1
    `;
    
    try {
        const result = await querySPARQL(parkAwareQuery);
        if (result) {
            console.log(`‚úì Found "${coasterName}" with park verification`);
            return result;
        }
    } catch (e) {
        console.warn(`    ‚ö†Ô∏è Park-aware search failed: ${e.message}`);
    }
    
    // STRATEGY 2: Fallback to name-only if park search failed
    // (Some coasters might not have park data in Wikidata)
    console.log(`  üîç Fast (Name-only fallback): "${variant}"`);
    const simpleQuery = `
        SELECT ?item ?image WHERE {
          ?item rdfs:label ?label .
          FILTER(CONTAINS(LCASE(?label), LCASE("${escapedName}")))
          ${coasterTypeFilter}
          ?item wdt:P18 ?image .
        }
        LIMIT 1
    `;
    
    try {
        const result = await querySPARQL(simpleQuery);
        if (result) {
            console.log(`‚úì Found "${coasterName}" (park not verified - may need retry)`);
            return result;
        }
    } catch (e) {
        console.warn(`    ‚ö†Ô∏è Fast search failed: ${e.message}`);
    }
    
    console.log(`‚úó No image found for "${coasterName}" (use retry button for intensive search)`);
    return null;
}

// Wikidata EntitySearch API - finds entities by name (more forgiving than SPARQL)
async function searchWikidataEntity(coasterName, validateType = true) {
    if (!coasterName || coasterName.length < 3) return null;
    
    const searchUrl = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodeURIComponent(coasterName)}&language=en&limit=5&format=json&origin=*`;
    
    // Roller coaster parent class for validation
    const rollerCoasterClassId = 'Q204832';
    
    try {
        const response = await fetchWithTimeout(searchUrl, {}, 10000);
        if (!response.ok) return null;
        
        const data = await response.json();
        if (!data.search || data.search.length === 0) return null;
        
        // Check each result for an image
        for (const entity of data.search) {
            const entityId = entity.id;
            
            // Fetch entity data to check for image and type
            const entityUrl = `https://www.wikidata.org/w/api.php?action=wbgetentities&ids=${entityId}&props=claims&format=json&origin=*`;
            const entityResponse = await fetchWithTimeout(entityUrl, {}, 10000);
            if (!entityResponse.ok) continue;
            
            const entityData = await entityResponse.json();
            const claims = entityData?.entities?.[entityId]?.claims;
            
            if (!claims) continue;
            
            // If validation required, check if it's a roller coaster
            if (validateType && claims.P31) {
                const instanceOfClaims = claims.P31;
                // Check if entity is directly a roller coaster or any of its subclasses
                const hasCoasterType = instanceOfClaims.some(claim => {
                    const typeId = claim.mainsnak?.datavalue?.value?.id;
                    return typeId === rollerCoasterClassId;
                });
                
                // If not directly a roller coaster, check P279 (subclass of) chain
                if (!hasCoasterType && claims.P279) {
                    const subclassOfClaims = claims.P279;
                    const isCoasterSubclass = subclassOfClaims.some(claim => {
                        const parentId = claim.mainsnak?.datavalue?.value?.id;
                        return parentId === rollerCoasterClassId;
                    });
                    
                    if (!isCoasterSubclass) {
                        console.log(`    ‚ö†Ô∏è EntitySearch: ${entity.label} is not a roller coaster, skipping`);
                        continue;
                    }
                } else if (!hasCoasterType) {
                    console.log(`    ‚ö†Ô∏è EntitySearch: ${entity.label} is not a roller coaster, skipping`);
                    continue;
                }
            }
            
            // Check for image (P18 property)
            if (claims.P18 && claims.P18.length > 0) {
                const imageFile = claims.P18[0].mainsnak?.datavalue?.value;
                if (imageFile) {
                    // Convert Commons filename to URL
                    const imageUrl = `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(imageFile)}`;
                    return imageUrl;
                }
            }
        }
        
        return null;
    } catch (error) {
        console.warn('EntitySearch error:', error.message);
        return null;
    }
}

// Intensive image search with park/manufacturer verification (triggered by retry button)
async function intensiveImageSearch(coasterName, parkName, manufacturer) {
    console.log(`\nüî¨ INTENSIVE SEARCH for "${coasterName}" at ${parkName}...`);
    
    const escapeSPARQL = (str) => str.replace(/["\\]/g, '\\$&');
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    // Roller coaster type validation
    const coasterTypeFilter = `?item wdt:P31/wdt:P279* wd:Q204832 .`;
    
    // Generate all name variants (not just first 3)
    const nameVariants = [];
    let cleanName = coasterName.trim().replace(/\s+/g, ' ');
    
    nameVariants.push(cleanName);
    
    if (cleanName.includes('(')) {
        nameVariants.push(cleanName.replace(/\s*\([^)]*\)/g, ''));
    }
    if (cleanName.includes(' - ')) {
        nameVariants.push(cleanName.split(' - ')[0].trim());
    }
    if (cleanName.includes(':')) {
        nameVariants.push(cleanName.split(':')[0].trim());
    }
    
    console.log(`  üìù Trying ${nameVariants.length} variants with park filtering...`);
    
    // Strategy: CONTAINS with park verification
    for (const variant of nameVariants) {
        const escapedName = escapeSPARQL(variant);
        const escapedPark = escapeSPARQL(parkName);
        
        if (variant.length < 3) continue;
        
        console.log(`  üîç Searching "${variant}" with park context...`);
        
        // Query with park and manufacturer metadata
        const query = `
            SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
              ?item rdfs:label ?label .
              FILTER(CONTAINS(LCASE(?label), LCASE("${escapedName}")))
              ${coasterTypeFilter}
              ?item wdt:P18 ?image .
              
              OPTIONAL { 
                ?item wdt:P127 ?park . 
                ?park rdfs:label ?parkLabel . 
                FILTER(lang(?parkLabel) = "en" || lang(?parkLabel) = "de")
              }
              OPTIONAL { 
                ?item wdt:P176 ?mfg . 
                ?mfg rdfs:label ?mfgLabel . 
                FILTER(lang(?mfgLabel) = "en")
              }
              ?item rdfs:label ?itemLabel . 
              FILTER(lang(?itemLabel) = "en" || lang(?itemLabel) = "de")
            }
            LIMIT 5
        `;
        
        try {
            const results = await querySPARQLMultiple(query);
            
            if (results && results.length > 0) {
                console.log(`  ‚úì Found ${results.length} candidates`);
                
                // Try to find best match based on park
                for (const result of results) {
                    const itemLabel = result.itemLabel?.value || '';
                    const parkLabel = result.parkLabel?.value || '';
                    const mfgLabel = result.mfgLabel?.value || '';
                    const imageUrl = result.image?.value;
                    
                    console.log(`    Candidate: ${itemLabel} at ${parkLabel || '(unknown)'} by ${mfgLabel || '(unknown)'}`);
                    
                    // Check if park matches
                    const parkMatches = parkLabel && (
                        parkLabel.toLowerCase().includes(parkName.toLowerCase()) ||
                        parkName.toLowerCase().includes(parkLabel.toLowerCase())
                    );
                    
                    if (parkMatches) {
                        console.log(`    ‚úÖ Park match! Using this result.`);
                        
                        if (imageUrl) {
                            const finalUrl = imageUrl.startsWith('http://') 
                                ? imageUrl.replace('http://', 'https://') 
                                : imageUrl;
                            
                            return {
                                url: finalUrl,
                                metadata: {
                                    name: itemLabel,
                                    park: parkLabel,
                                    manufacturer: mfgLabel,
                                    verified: true
                                }
                            };
                        }
                    }
                }
                
                // If no park match, use first result but mark as unverified
                const firstResult = results[0];
                const imageUrl = firstResult.image?.value;
                
                if (imageUrl) {
                    console.log(`    ‚ö†Ô∏è Using first result (park not verified)`);
                    const finalUrl = imageUrl.startsWith('http://') 
                        ? imageUrl.replace('http://', 'https://') 
                        : imageUrl;
                    
                    return {
                        url: finalUrl,
                        metadata: {
                            name: firstResult.itemLabel?.value || '',
                            park: firstResult.parkLabel?.value || '',
                            manufacturer: firstResult.mfgLabel?.value || '',
                            verified: false
                        }
                    };
                }
            }
            
            await delay(200);
        } catch (e) {
            console.warn(`    ‚ö†Ô∏è Query failed: ${e.message}`);
            await delay(200);
        }
    }
    
    console.log(`  ‚úó No image found after intensive search`);
    return null;
}

// Query SPARQL endpoint and return multiple results
async function querySPARQLMultiple(query, timeoutMs = 20000) {
    const url = 'https://query.wikidata.org/sparql';
    const fullUrl = `${url}?query=${encodeURIComponent(query)}&format=json`;
    
    try {
        const response = await fetchWithTimeout(fullUrl, {
            headers: {
                'Accept': 'application/sparql-results+json',
                'User-Agent': 'CoasterRanker/1.0 (Educational Project)'
            }
        }, timeoutMs);
        
        if (!response.ok) {
            if (response.status === 429) {
                throw new Error('429 Rate limit');
            }
            return null;
        }
        
        const data = await response.json();
        return data?.results?.bindings || null;
    } catch (error) {
        console.error('SPARQL query error:', error);
        return null;
    }
}

// Track retry attempts per coaster
const retryAttempts = new Map();

// Retry button handler (called from dev-data overlay)
window.retryCoasterImage = async function(coasterName, parkName, manufacturer, elementId, event) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }
    
    const button = event ? event.target : null;
    const infoDiv = document.getElementById(`imageInfo_${elementId}`);
    
    const attemptKey = normalizeCoasterName(coasterName);
    const currentAttempt = retryAttempts.get(attemptKey) || 0;
    retryAttempts.set(attemptKey, currentAttempt + 1);
    
    if (button) {
        button.disabled = true;
        button.textContent = '‚è≥ Searching...';
    }
    
    if (infoDiv) {
        infoDiv.textContent = 'Searching...';
        infoDiv.style.color = '#ffffff';
    }
    
    try {
        const allResults = await intensiveImageSearch(coasterName, parkName, manufacturer, true);
        
        let result = null;
        if (allResults && allResults.length > 0) {
            if (currentAttempt < allResults.length) {
                result = allResults[currentAttempt];
            } else {
                retryAttempts.set(attemptKey, 0);
                result = null;
            }
        }
        
        if (result && result.url) {
            const normalizedName = normalizeCoasterName(coasterName);
            const normalizedPark = normalizeCoasterName(parkName);
            const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
            localStorage.setItem(cacheKey, result.url);
            
            const cards = document.querySelectorAll('.coaster-card');
            cards.forEach(card => {
                const nameEl = card.querySelector('.coaster-name');
                const cardName = nameEl?.textContent;
                if (nameEl && nameEl.textContent === coasterName) {
                    const img = card.querySelector('.coaster-img');
                    if (img) {
                        const oldSrc = img.src;
                        img.src = result.url;
                    }
                }
            });
            
            // Display verification result
            if (infoDiv) {
                const icon = result.metadata.verified ? '‚úì‚úì' : (result.metadata.parkMatch || result.metadata.mfgMatch ? '‚úì' : '‚ö†Ô∏è');
                const parkInfo = parkName ? `in ${parkName}` : '';
                const imageNum = allResults?.length > 1 ? ` [${currentAttempt + 1}/${allResults.length}]` : '';
                
                infoDiv.innerHTML = `${icon} ${result.metadata.name} ${parkInfo}${imageNum}`;
                infoDiv.style.color = result.metadata.verified ? '#10b981' : (result.metadata.parkMatch || result.metadata.mfgMatch ? '#ffffff' : '#ef4444');
                
                // Add warning for park mismatch only
                if (!result.metadata.parkMatch && result.metadata.park) {
                    infoDiv.innerHTML += `<br><span style="font-size:0.8em;color:#ef4444;">‚ö†Ô∏è Expected park: ${parkName}</span>`;
                }
                
                // Show that image is saved
                infoDiv.innerHTML += `<br><span style="font-size:0.8em;color:#6b7280;">üíæ Saved - will persist in future battles</span>`;
            }
            
            if (button) {
                button.textContent = '‚úì Updated';
                setTimeout(() => {
                    button.textContent = 'üîÑ Retry Image';
                    button.disabled = false;
                }, 2000);
            }
            
            console.log('  ‚úì Retry complete!');
        } else {
            const placeholderUrl = getPlaceholderImage();
            
            const normalizedName = normalizeCoasterName(coasterName);
            const normalizedPark = normalizeCoasterName(parkName);
            const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
            localStorage.setItem(cacheKey, placeholderUrl);
            
            const cards = document.querySelectorAll('.coaster-card');
            cards.forEach(card => {
                const nameEl = card.querySelector('.coaster-name');
                if (nameEl && nameEl.textContent === coasterName) {
                    const img = card.querySelector('.coaster-img');
                    if (img) img.src = placeholderUrl;
                }
            });
            
            if (infoDiv) {
                const message = allResults?.length > 0 ? `All ${allResults.length} images tried` : 'No image found';
                infoDiv.textContent = `üîÑ ${message} - Using placeholder`;
                infoDiv.style.color = '#ffffff';
            }
            if (button) {
                button.textContent = 'üîÑ Try Again';
                button.disabled = false;
            }
        }
    } catch (error) {
        console.error('Retry image error:', error);
        if (infoDiv) {
            infoDiv.textContent = '‚úó Search failed';
            infoDiv.style.color = '#ef4444';
        }
        if (button) {
            button.textContent = '‚úó Error';
            setTimeout(() => {
                button.textContent = 'üîÑ Retry Image';
                button.disabled = false;
            }, 2000);
        }
    }
};

// Intensive image search with park/manufacturer verification (triggered by retry button)
async function intensiveImageSearch(coasterName, parkName, manufacturer, returnAll = false) {
    
    const escapeSPARQL = (str) => str.replace(/["\\]/g, '\\$&');
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    // Roller coaster type validation
    const coasterTypeFilter = `?item wdt:P31/wdt:P279* wd:Q204832 .`;
    
    // Collection for all found results when returnAll=true
    const allFoundMatches = [];
    
    // Helper function to process results with scoring (defined early for use in all strategies)
    const processResults = (results, strategy) => {
        if (!results || results.length === 0) return returnAll ? [] : null;
        
        console.log(`  ‚úì ${strategy}: Found ${results.length} candidates`);
        
        // If returnAll is true, collect all valid results
        if (returnAll) {
            const allMatches = [];
            const seenUrls = new Set(); // Track URLs to avoid duplicates
            
            for (const result of results) {
                const itemLabel = result.itemLabel?.value || '';
                const parkLabel = result.parkLabel?.value || '';
                const mfgLabel = result.mfgLabel?.value || '';
                const imageUrl = result.image?.value;
                
                if (!imageUrl) continue; // Skip results without images
                
                // Normalize URL and check for duplicates
                const normalizedUrl = imageUrl.startsWith('http://') ? imageUrl.replace('http://', 'https://') : imageUrl;
                if (seenUrls.has(normalizedUrl)) {
                    console.log(`    ‚è≠Ô∏è Skipping duplicate image`);
                    continue;
                }
                seenUrls.add(normalizedUrl);
                
                console.log(`    Candidate: ${itemLabel} at ${parkLabel || '(unknown)'} by ${mfgLabel || '(unknown)'}`);
                
                const parkMatches = parkLabel && (
                    parkLabel.toLowerCase().includes(parkName.toLowerCase()) ||
                    parkName.toLowerCase().includes(parkLabel.toLowerCase())
                );
                
                const mfgMatches = mfgLabel && manufacturer && (
                    mfgLabel.toLowerCase().includes(manufacturer.toLowerCase()) ||
                    manufacturer.toLowerCase().includes(mfgLabel.toLowerCase())
                );
                
                // Calculate match score - PRIORITIZE PARK MATCHES
                let score = 0;
                let qualityLabel = '';
                if (parkMatches && mfgMatches) {
                    score = 100;
                    qualityLabel = 'PERFECT MATCH';
                    console.log(`    ‚úÖ‚úÖ PERFECT MATCH!`);
                } else if (parkMatches) {
                    score = 50;
                    qualityLabel = 'PARK VERIFIED';
                    console.log(`    ‚úÖ Park verified`);
                } else if (mfgMatches) {
                    score = 1;
                    qualityLabel = 'MFG ONLY';
                    console.log(`    ‚ö†Ô∏è Manufacturer only`);
                } else {
                    score = 0;
                    qualityLabel = 'UNVERIFIED';
                }
                
                allMatches.push({
                    url: normalizedUrl,
                    metadata: {
                        name: itemLabel,
                        park: parkLabel,
                        manufacturer: mfgLabel,
                        verified: score === 100,
                        parkMatch: parkMatches,
                        mfgMatch: mfgMatches,
                        qualityLabel: qualityLabel
                    },
                    score: score
                });
            }
            
            // Sort by score (best first)
            allMatches.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                const aParkLen = a.metadata.park?.length || 999;
                const bParkLen = b.metadata.park?.length || 999;
                return aParkLen - bParkLen;
            });
            
            console.log(`  üìä Sorted results: ${allMatches.map(m => `${m.metadata.qualityLabel} (${m.score})`).join(', ')}`);
            return allMatches;
        }
        
        // Original logic for returning single best match (when returnAll=false)
        let bestMatch = null;
        let bestScore = 0;
        
        for (const result of results) {
            const itemLabel = result.itemLabel?.value || '';
            const parkLabel = result.parkLabel?.value || '';
            const mfgLabel = result.mfgLabel?.value || '';
            const imageUrl = result.image?.value;
            
            console.log(`    Candidate: ${itemLabel} at ${parkLabel || '(unknown)'} by ${mfgLabel || '(unknown)'}`);
            
            const parkMatches = parkLabel && (
                parkLabel.toLowerCase().includes(parkName.toLowerCase()) ||
                parkName.toLowerCase().includes(parkLabel.toLowerCase())
            );
            
            const mfgMatches = mfgLabel && manufacturer && (
                mfgLabel.toLowerCase().includes(manufacturer.toLowerCase()) ||
                manufacturer.toLowerCase().includes(mfgLabel.toLowerCase())
            );
            
            // Calculate match score
            let score = 0;
            if (parkMatches && mfgMatches) {
                score = 100;
                console.log(`    ‚úÖ‚úÖ PERFECT MATCH!`);
            } else if (parkMatches) {
                score = 50;
                console.log(`    ‚úÖ Park verified`);
            } else if (mfgMatches) {
                score = 1;
                console.log(`    ‚ö†Ô∏è Manufacturer only`);
            }
            
            if (score > bestScore && imageUrl) {
                bestScore = score;
                bestMatch = {
                    url: imageUrl.startsWith('http://') ? imageUrl.replace('http://', 'https://') : imageUrl,
                    metadata: {
                        name: itemLabel,
                        park: parkLabel,
                        manufacturer: mfgLabel,
                        verified: score === 100,
                        parkMatch: parkMatches,
                        mfgMatch: mfgMatches
                    }
                };
                
                // Return immediately on perfect match
                if (score === 100) {
                    console.log(`    üéØ Using perfect match!`);
                    return bestMatch;
                }
            }
        }
        
        // Use first result if no matches
        if (!bestMatch && results[0]?.image?.value) {
            const firstResult = results[0];
            const imageUrl = firstResult.image.value;
            bestMatch = {
                url: imageUrl.startsWith('http://') ? imageUrl.replace('http://', 'https://') : imageUrl,
                metadata: {
                    name: firstResult.itemLabel?.value || '',
                    park: firstResult.parkLabel?.value || '',
                    manufacturer: firstResult.mfgLabel?.value || '',
                    verified: false,
                    parkMatch: false,
                    mfgMatch: false
                }
            };
            console.log(`    ‚ö†Ô∏è Using first result (unverified)`);
        }
        
        return bestMatch;
    };
    
    // STRATEGY 0: Combined Park+Name query (HIGHEST PRIORITY - most accurate)
    console.log(`  üéØ STRATEGY 0: Combined Park+Name filter (most accurate)`);
    
    // Generate SMART basic name variants for Strategy 0 (avoid over-generation)
    const basicVariants = new Set();
    let cleanName = coasterName.trim().replace(/\s+/g, ' ');
    basicVariants.add(cleanName);
    
    // First try with just the basic name
    let foundBasicResults = false;
    
    for (const nameVariant of Array.from(basicVariants).slice(0, 3)) { // Max 3 variants for Strategy 0
        console.log(`  üîç COMBINED: "${nameVariant}" + "${parkName}"`);
        
        const combinedQuery = `
            SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
              ?item rdfs:label ?itemLabel .
              FILTER(CONTAINS(LCASE(?itemLabel), LCASE("${escapeSPARQL(nameVariant)}")))
              
              ${coasterTypeFilter}
              ?item wdt:P18 ?image .
              
              ?item wdt:P127 ?park .
              ?park rdfs:label ?parkLabel .
              FILTER(CONTAINS(LCASE(?parkLabel), LCASE("${escapeSPARQL(parkName)}")))
              
              OPTIONAL { 
                ?item wdt:P176 ?mfg . 
                ?mfg rdfs:label ?mfgLabel . 
                FILTER(lang(?mfgLabel) = "en")
              }
            }
            LIMIT 10
        `;
        
        try {
            const results = await querySPARQLMultiple(combinedQuery, 15000);
            console.log(`    üìä Combined query results: ${results?.length || 0}`);
            
            if (results && results.length > 0) {
                const match = processResults(results, 'COMBINED');
                if (returnAll && Array.isArray(match) && match.length > 0) {
                    allFoundMatches.push(...match);
                    foundBasicResults = true;
                    console.log(`    ‚úì COMBINED found ${match.length} results`);
                } else if (!returnAll && match) {
                    console.log(`    üéØ COMBINED found best match!`);
                    return match;
                }
            }
            await delay(200);
        } catch (e) {
            console.warn(`    ‚ö†Ô∏è COMBINED failed: ${e.message}`);
            await delay(200);
        }
    }
    
    // Only try accent variants if no basic results found
    if (!foundBasicResults && returnAll) {
        console.log(`  üî§ No results from basic search, trying accent variants...`);
        
        // Simplify first (remove punctuation) - often helps
        const simplified = cleanName.replace(/[']/g, '').replace(/ - /g, ' ').trim();
        if (simplified !== cleanName && simplified.length >= 3) {
            basicVariants.add(simplified);
        }
        
        // Only use KNOWN accent substitutions (not random combinations)
        const knownAccentMap = {
            'fenix': 'F√©nix',
            'phoenix': 'F√©nix',
            'geforce': 'G-Force',
            'baron': 'Baron 1898',
            'joris': 'Joris en de Draak'
        };
        
        const lowerName = cleanName.toLowerCase();
        for (const [from, to] of Object.entries(knownAccentMap)) {
            if (lowerName.includes(from)) {
                basicVariants.add(to);
            }
        }
        
        // Try accent variants (skip first one as it was already tried)
        for (const nameVariant of Array.from(basicVariants).slice(1, 3)) {
            console.log(`  üîç COMBINED VARIANT: "${nameVariant}" + "${parkName}"`);
            
            const combinedQuery = `
                SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
                  ?item rdfs:label ?itemLabel .
                  FILTER(CONTAINS(LCASE(?itemLabel), LCASE("${escapeSPARQL(nameVariant)}")))
                  
                  ${coasterTypeFilter}
                  ?item wdt:P18 ?image .
                  
                  ?item wdt:P127 ?park .
                  ?park rdfs:label ?parkLabel .
                  FILTER(CONTAINS(LCASE(?parkLabel), LCASE("${escapeSPARQL(parkName)}")))
                  
                  OPTIONAL { 
                    ?item wdt:P176 ?mfg . 
                    ?mfg rdfs:label ?mfgLabel . 
                    FILTER(lang(?mfgLabel) = "en")
                  }
                }
                LIMIT 10
            `;
            
            try {
                const results = await querySPARQLMultiple(combinedQuery, 15000);
                console.log(`    üìä Combined variant query results: ${results?.length || 0}`);
                
                if (results && results.length > 0) {
                    const match = processResults(results, 'COMBINED');
                    if (Array.isArray(match) && match.length > 0) {
                        allFoundMatches.push(...match);
                        console.log(`    ‚úì COMBINED VARIANT found ${match.length} results`);
                    }
                }
                await delay(200);
            } catch (e) {
                console.warn(`    ‚ö†Ô∏è COMBINED VARIANT failed: ${e.message}`);
                await delay(200);
            }
        }
    } else if (foundBasicResults) {
        console.log(`  ‚ö° Basic search found results, skipping accent variants for speed`);
    }
    
    // If combined search succeeded and returnAll, we can return early
    if (returnAll && allFoundMatches.length >= 3) {
        console.log(`  ‚úì Strategy 0 found ${allFoundMatches.length} good matches, skipping other strategies`);
        // Still deduplicate and sort
        const uniqueMatches = [];
        const seenUrls = new Set();
        for (const match of allFoundMatches) {
            if (!seenUrls.has(match.url)) {
                seenUrls.add(match.url);
                uniqueMatches.push(match);
            }
        }
        uniqueMatches.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            const aParkLen = a.metadata.park?.length || 999;
            const bParkLen = b.metadata.park?.length || 999;
            return aParkLen - bParkLen;
        });
        return uniqueMatches;
    }
    
    // Continue with original strategies if Strategy 0 didn't find enough
    console.log(`  üìù Strategy 0 found ${allFoundMatches.length} results, continuing with fallback strategies...`);
    
    // Generate smart name variants and deduplicate
    const nameVariants = new Set();
    cleanName = coasterName.trim().replace(/\s+/g, ' ');
    
    nameVariants.add(cleanName);
    
    // Remove parentheses (e.g., "Crazy Bats (VR)" ‚Üí "Crazy Bats")
    if (cleanName.includes('(')) {
        nameVariants.add(cleanName.replace(/\s*\([^)]*\)/g, '').trim());
    }
    
    // Remove subtitle after dash (e.g., "Colossos - Kampf" ‚Üí "Colossos")
    if (cleanName.includes(' - ')) {
        nameVariants.add(cleanName.split(' - ')[0].trim());
    }
    
    // Remove subtitle after colon (e.g., "Xpress: Platform 13" ‚Üí "Xpress")
    if (cleanName.includes(':')) {
        nameVariants.add(cleanName.split(':')[0].trim());
    }
    
    // Remove "Der/Die/Das" German articles (e.g., "Der Schwur des K√§rnan" ‚Üí "Schwur des K√§rnan")
    if (/^(Der|Die|Das) /i.test(cleanName)) {
        nameVariants.add(cleanName.replace(/^(Der|Die|Das) /i, '').trim());
    }
    
    // Remove "The" English article (e.g., "The Smiler" ‚Üí "Smiler")
    if (/^The /i.test(cleanName)) {
        nameVariants.add(cleanName.replace(/^The /i, '').trim());
    }
    
    // Remove hyphens (e.g., "Hals-√ºber-Kopf" ‚Üí "Hals uber Kopf")
    if (cleanName.includes('-')) {
        nameVariants.add(cleanName.replace(/-/g, ' ').trim());
    }
    
    // Remove apostrophes (e.g., "Winja's" ‚Üí "Winjas")
    if (cleanName.includes("'")) {
        nameVariants.add(cleanName.replace(/'/g, '').trim());
    }
    
    // Try without special characters/accents (e.g., "K√∂ln" ‚Üí "Koln", "√ºber" ‚Üí "uber")
    const normalized = cleanName.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    if (normalized !== cleanName) {
        nameVariants.add(normalized);
    }
    
    // Try common English/German spellings (e.g., "√º" ‚Üí "ue", "√∂" ‚Üí "oe", "√§" ‚Üí "ae")
    const germanized = cleanName
        .replace(/√º/g, 'ue')
        .replace(/√∂/g, 'oe')
        .replace(/√§/g, 'ae')
        .replace(/√ü/g, 'ss')
        .replace(/√ú/g, 'Ue')
        .replace(/√ñ/g, 'Oe')
        .replace(/√Ñ/g, 'Ae');
    if (germanized !== cleanName) {
        nameVariants.add(germanized);
    }
    
    // REMOVED: Random accent generation - too many useless variants
    // Only use known substitutions below
    
    // Common name variations (TARGETED - only known coasters)
    const nameSubstitutions = {
        'fenix': 'F√©nix',
        'phoenix': 'F√©nix',
        'geforce': 'G-Force',
        'baron': 'Baron 1898'
    };
    
    const lowerCleanName = cleanName.toLowerCase();
    for (const [from, to] of Object.entries(nameSubstitutions)) {
        if (lowerCleanName === from || lowerCleanName.includes(from)) {
            const replaced = cleanName.replace(new RegExp(from, 'gi'), to);
            if (replaced !== cleanName && replaced.length >= 3) {
                nameVariants.add(replaced);
            }
        }
    }
    
    // Convert to array and filter out short names (< 3 chars)
    const variants = Array.from(nameVariants).filter(v => v.length >= 3);
    
    console.log(`  üìù Generated ${variants.length} additional name variants for fallback:`, variants);
    console.log(`  üéØ Fallback Strategies: CONTAINS (all langs), EXACT (multi-lang), RELAXED (no type filter)`);
    
    // Strategy 1: CONTAINS search (all languages automatically)
    for (const variant of variants) {
        const escapedName = escapeSPARQL(variant);
        console.log(`  üîç CONTAINS: "${variant}"`);
        
        const containsQuery = `
            SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
              ?item rdfs:label ?label .
              FILTER(CONTAINS(LCASE(?label), LCASE("${escapedName}")))
              ${coasterTypeFilter}
              ?item wdt:P18 ?image .
              OPTIONAL { 
                ?item wdt:P127 ?park . 
                ?park rdfs:label ?parkLabel . 
                FILTER(lang(?parkLabel) = "en")
              }
              OPTIONAL { 
                ?item wdt:P176 ?mfg . 
                ?mfg rdfs:label ?mfgLabel . 
                FILTER(lang(?mfgLabel) = "en")
              }
              ?item rdfs:label ?itemLabel . 
              FILTER(lang(?itemLabel) = "en")
            }
            LIMIT 10
        `;
        
        try {
            const results = await querySPARQLMultiple(containsQuery);
            console.log(`    üìä Raw results count: ${results?.length || 0}`);
            if (results && results.length > 0) {
                console.log(`    üì∏ First result has image: ${!!results[0]?.image?.value}`);
                if (results[0]?.image?.value) {
                    console.log(`    üîó Image URL: ${results[0].image.value}`);
                }
            }
            const match = processResults(results, 'CONTAINS');
            if (returnAll && Array.isArray(match) && match.length > 0) {
                // Collect all results for cycling
                allFoundMatches.push(...match);
                // Early exit if we found enough good results
                if (allFoundMatches.length >= 5) {
                    console.log(`  ‚úì Found ${allFoundMatches.length} images, stopping early`);
                    break;
                }
            } else if (!returnAll && match) {
                // Return single best result
                return match;
            }
            await delay(150);
        } catch (e) {
            console.warn(`    ‚ö†Ô∏è CONTAINS failed: ${e.message}`);
            await delay(150);
        }
    }
    
    // Skip EXACT strategy if we already have enough results
    if (returnAll && allFoundMatches.length >= 5) {
        console.log(`  ‚è≠Ô∏è Skipping EXACT strategy - already have ${allFoundMatches.length} results`);
    } else {
        // Strategy 2: Exact match in English, German, Dutch, French, Spanish
        for (const variant of variants) {
            const escapedName = escapeSPARQL(variant);
            console.log(`  üîç EXACT (en+de+nl+fr+es): "${variant}"`);
        
        const exactQuery = `
            SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
              {
                ?item rdfs:label "${escapedName}"@en .
              }
              UNION {
                ?item rdfs:label "${escapedName}"@de .
              }
              UNION {
                ?item rdfs:label "${escapedName}"@nl .
              }
              UNION {
                ?item rdfs:label "${escapedName}"@fr .
              }
              UNION {
                ?item rdfs:label "${escapedName}"@es .
              }
              ${coasterTypeFilter}
              ?item wdt:P18 ?image .
              OPTIONAL { 
                ?item wdt:P127 ?park . 
                ?park rdfs:label ?parkLabel . 
                FILTER(lang(?parkLabel) = "en")
              }
              OPTIONAL { 
                ?item wdt:P176 ?mfg . 
                ?mfg rdfs:label ?mfgLabel . 
                FILTER(lang(?mfgLabel) = "en")
              }
              ?item rdfs:label ?itemLabel . 
              FILTER(lang(?itemLabel) = "en")
            }
            LIMIT 10
        `;
        
        try {
            const results = await querySPARQLMultiple(exactQuery);
            const match = processResults(results, 'EXACT');
            if (returnAll && Array.isArray(match) && match.length > 0) {
                // Collect all results for cycling
                allFoundMatches.push(...match);
                // Early exit if we found enough good results
                if (allFoundMatches.length >= 5) {
                    console.log(`  ‚úì Found ${allFoundMatches.length} images, stopping early`);
                    break;
                }
            } else if (!returnAll && match) {
                // Return single best result
                return match;
            }
            await delay(150);
        } catch (e) {
            console.warn(`    ‚ö†Ô∏è EXACT failed: ${e.message}`);
            await delay(150);
        }
        }
    }
    
    // Strategy 3: Relaxed search without strict type filter (if no results yet)
    if (returnAll && allFoundMatches.length === 0) {
        console.log(`  üîì RELAXED: Trying without strict type filter...`);
        for (const variant of variants.slice(0, 3)) { // Try first 3 variants
            const escapedName = escapeSPARQL(variant);
            console.log(`  üîç RELAXED: "${variant}"`);
            
            // More targeted relaxed query - add park filter to narrow results
            const parkFilter = parkName ? `
              OPTIONAL { 
                ?item wdt:P127 ?park . 
                ?park rdfs:label ?parkLabel . 
                FILTER(lang(?parkLabel) = "en")
              }
              FILTER(!BOUND(?park) || CONTAINS(LCASE(?parkLabel), LCASE("${escapeSPARQL(parkName)}")))
            ` : '';
            
            const relaxedQuery = `
                SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
                  ?item rdfs:label ?label .
                  FILTER(CONTAINS(LCASE(?label), LCASE("${escapedName}")))
                  ?item wdt:P18 ?image .
                  ${parkFilter}
                  OPTIONAL { 
                    ?item wdt:P176 ?mfg . 
                    ?mfg rdfs:label ?mfgLabel . 
                    FILTER(lang(?mfgLabel) = "en")
                  }
                  ?item rdfs:label ?itemLabel . 
                  FILTER(lang(?itemLabel) = "en")
                }
                LIMIT 5
            `;
            
            try {
                const results = await querySPARQLMultiple(relaxedQuery, 30000); // 30 second timeout for relaxed
                const match = processResults(results, 'RELAXED');
                if (Array.isArray(match) && match.length > 0) {
                    allFoundMatches.push(...match);
                    console.log(`    ‚úì RELAXED found ${match.length} results`);
                }
                await delay(200);
            } catch (e) {
                console.warn(`    ‚ö†Ô∏è RELAXED failed: ${e.message}`);
                // Don't block on RELAXED failures - continue with what we have
                await delay(200);
            }
        }
    }
    
    // Return all collected results
    if (returnAll) {
        // Deduplicate by URL
        const uniqueMatches = [];
        const seenUrls = new Set();
        for (const match of allFoundMatches) {
            if (!seenUrls.has(match.url)) {
                seenUrls.add(match.url);
                uniqueMatches.push(match);
            }
        }
        
        // Re-sort after combining strategies
        uniqueMatches.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            const aParkLen = a.metadata.park?.length || 999;
            const bParkLen = b.metadata.park?.length || 999;
            return aParkLen - bParkLen;
        });
        
        console.log(`  ‚úì Total unique images found: ${uniqueMatches.length}`);
        return uniqueMatches.length > 0 ? uniqueMatches : [];
    }
    
    console.log(`  ‚úó No image found after intensive search`);
    return returnAll ? [] : null;
}

// Enhanced search for second round bulk loading (combines coaster name + park for better results)
async function enhancedCoasterImageSearch(coaster) {
    if (!coaster?.naam || !coaster?.park) return null;
    
    const coasterName = coaster.naam;
    const parkName = coaster.park;
    const manufacturer = coaster.fabrikant;
    
    console.log(`  üîç Enhanced search: "${coasterName}" at ${parkName}`);
    
    const escapeSPARQL = (str) => str.replace(/["\\]/g, '\\$&');
    const coasterTypeFilter = `?item wdt:P31/wdt:P279* wd:Q204832 .`;
    
    // Create a targeted query that searches for BOTH coaster name AND park name
    const enhancedQuery = `
        SELECT ?item ?image ?itemLabel ?parkLabel ?mfgLabel WHERE {
          ?item rdfs:label ?itemLabel .
          FILTER(CONTAINS(LCASE(?itemLabel), LCASE("${escapeSPARQL(coasterName)}")))
          FILTER(lang(?itemLabel) = "en")
          
          ${coasterTypeFilter}
          ?item wdt:P18 ?image .
          
          ?item wdt:P127 ?park .
          ?park rdfs:label ?parkLabel .
          FILTER(CONTAINS(LCASE(?parkLabel), LCASE("${escapeSPARQL(parkName)}")))
          FILTER(lang(?parkLabel) = "en")
          
          OPTIONAL { 
            ?item wdt:P176 ?mfg . 
            ?mfg rdfs:label ?mfgLabel . 
            FILTER(lang(?mfgLabel) = "en")
          }
        }
        LIMIT 5
    `;
    
    try {
        const results = await querySPARQLMultiple(enhancedQuery, 15000);
        
        if (results && results.length > 0) {
            console.log(`    ‚úì Enhanced search found ${results.length} results`);
            
            // Pick best match (prefer manufacturer match if available)
            let bestMatch = results[0];
            for (const result of results) {
                const mfgLabel = result.mfgLabel?.value || '';
                if (manufacturer && mfgLabel.toLowerCase().includes(manufacturer.toLowerCase())) {
                    bestMatch = result;
                    break;
                }
            }
            
            const imageUrl = bestMatch.image?.value;
            if (imageUrl) {
                const finalUrl = imageUrl.startsWith('http://') ? imageUrl.replace('http://', 'https://') : imageUrl;
                
                // Cache the found image
                const normalizedName = normalizeCoasterName(coasterName);
                const normalizedPark = normalizeCoasterName(parkName);
                const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
                localStorage.setItem(cacheKey, finalUrl);
                
                console.log(`    ‚úì Cached enhanced result for "${coasterName}"`);
                return finalUrl;
            }
        }
    } catch (error) {
        console.warn(`    ‚ö†Ô∏è Enhanced search failed: ${error.message}`);
    }
    
    return null;
}

// Helper function to add timeout to fetch requests
async function fetchWithTimeout(url, options = {}, timeoutMs = 20000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Request timeout');
        }
        throw error;
    }
}

// Execute SPARQL query against Wikidata
async function querySPARQL(query) {
    const endpoint = 'https://query.wikidata.org/sparql';
    const url = `${endpoint}?query=${encodeURIComponent(query)}&format=json`;
    
    try {
        const response = await fetchWithTimeout(url, {
            headers: {
                'Accept': 'application/sparql-results+json',
                'User-Agent': 'CoasterRanker/1.0 (Educational Project)'
            }
        }, 20000); // 20 second timeout
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('SPARQL query failed:', response.status, response.statusText);
            console.error('Error details:', errorText.substring(0, 500));
            throw new Error(`SPARQL query failed: ${response.status}`);
        }
        
        const data = await response.json();
        const bindings = data?.results?.bindings;
        
        if (bindings && bindings.length > 0 && bindings[0].image) {
            let imageUrl = bindings[0].image.value;
            // Ensure HTTPS to avoid mixed content warnings
            if (imageUrl.startsWith('http://')) {
                imageUrl = imageUrl.replace('http://', 'https://');}
            return imageUrl;
        }
        
        return null;
    } catch (error) {
        console.error('SPARQL fetch error:', error.message);
        throw error;
    }
}

// Get coaster image (from cache or fetch from Wikidata)
async function getCoasterImage(coaster) {
    if (!coaster || !coaster.naam) return getPlaceholderImage();
    
    const normalizedName = normalizeCoasterName(coaster.naam);
    const normalizedPark = normalizeCoasterName(coaster.park);
    const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
    
    // Check cache first
    try {
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
            // Increment appropriate counter based on whether it's placeholder or real image
            if (cached.startsWith('data:image/svg+xml')) {
                // It's a cached placeholder (failed image)
                imageLoadStats.failed++;
            } else {
                // It's a real cached image
                imageLoadStats.loaded++;
            }
            imageLoadStats.cached++;
            return cached;
        }
    } catch (e) {
        console.warn('Cache read error:', e);
    }
    
    // Fetch from Wikidata
    try {
        const imageUrl = await queryWikidataImage(coaster.naam, coaster.park, coaster.fabrikant);
        
        if (imageUrl) {
            // Cache the result
            try {
                localStorage.setItem(cacheKey, imageUrl);
            } catch (e) {
                console.warn('Cache write error (quota?):', e);
            }
            imageLoadStats.loaded++;
            return imageUrl;
        } else {
            // No image found - cache placeholder to avoid repeated queries
            const placeholder = getPlaceholderImage();
            try {
                localStorage.setItem(cacheKey, placeholder);
            } catch (e) {
                console.warn('Cache write error:', e);
            }
            imageLoadStats.failed++;
            return placeholder;
        }
    } catch (error) {
        console.error('Error fetching image for', coaster.naam, ':', error);
        imageLoadStats.failed++;
        return getPlaceholderImage();
    }
}

// Synchronous cache-only image retrieval (for instant display in battles)
function getCoasterImageSync(coaster) {
    if (!coaster || !coaster.naam) return getPlaceholderImage();
    
    const normalizedName = normalizeCoasterName(coaster.naam);
    const normalizedPark = normalizeCoasterName(coaster.park);
    const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
    
    // Check memory cache first (fastest)
    if (imageMemoryCache.has(cacheKey)) {
        return imageMemoryCache.get(cacheKey);
    }
    
    // Check localStorage (slower)
    try {
        const cached = localStorage.getItem(cacheKey);
        if (cached) {
            // Store in memory cache for next time
            imageMemoryCache.set(cacheKey, cached);
            return cached;
        }
    } catch (e) {
        // Silent fail
    }
    
    // Return placeholder if not in cache
    return getPlaceholderImage();
}

// Preload a single image (returns promise that resolves when loaded)
function preloadImage(imageUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false); // Don't reject, just resolve with false
        img.src = imageUrl;
    });
}

// Preload images for a pair of coasters
async function preloadBattleImages(coaster1, coaster2) {
    const url1 = getCoasterImageSync(coaster1);
    const url2 = getCoasterImageSync(coaster2);
    
    // Load both in parallel
    await Promise.all([
        preloadImage(url1),
        preloadImage(url2)
    ]);
}

// Background preloader - loads images for next potential battles
async function preloadNextBattles() {
    if (isPreloading || !currentUser || !coasters || coasters.length < 2) return;
    
    isPreloading = true;
    const queueSize = keyboardUsageDetected ? PRELOAD_QUEUE_SIZE_FAST : PRELOAD_QUEUE_SIZE_NORMAL;
    
    try {
        // Generate next potential battles
        const battlesToPreload = [];
        for (let i = 0; i < queueSize; i++) {
            const pair = getRandomCoasters();
            if (pair && pair.length === 2) {
                battlesToPreload.push(pair);
            }
        }
        
        // Preload all images
        for (const [c1, c2] of battlesToPreload) {
            await preloadBattleImages(c1, c2);
        }
    } catch (e) {
        console.warn('Preload error:', e);
    } finally {
        isPreloading = false;
    }
}

// Clear all cached images from localStorage
function clearImageCache() {
    if (!confirm('Clear all cached coaster images? They will be re-fetched on next load.')) {
        return;
    }
    
    try {
        const keys = Object.keys(localStorage);
        let cleared = 0;
        
        keys.forEach(key => {
            if (key.startsWith('coasterImage_')) {
                localStorage.removeItem(key);
                cleared++;
            }
        });
        
        // Reset stats
        imageLoadStats = {
            loaded: 0,
            total: 0,
            failed: 0,
            cached: 0
        };
        
        updateImageLoadStats();
        showToast(`‚úÖ Cleared ${cleared} cached images`);
        
        // Reload images
        if (currentUser) {
            preloadCoasterImages();
        }
    } catch (e) {
        console.error('Error clearing cache:', e);
        showToast('‚ùå Failed to clear cache');
    }
}

// Auto-clean old cache versions (called on startup)
function cleanOldCacheVersions() {
    try {
        const keys = Object.keys(localStorage);
        let cleaned = 0;
        
        keys.forEach(key => {
            // Remove old version caches (anything not matching current version)
            if (key.startsWith('coasterImage_') && !key.startsWith(`coasterImage_${CACHE_VERSION}_`)) {
                localStorage.removeItem(key);
                cleaned++;
            }
        });
        
        if (cleaned > 0) {
            console.log(`üßπ Cleaned ${cleaned} old cache entries (outdated version)`);
        }
    } catch (e) {
        console.warn('Error cleaning old cache:', e);
    }
}

// Update dev menu with current image loading stats
function updateImageLoadStats() {
    const progressEl = document.getElementById('imageLoadProgress');
    const detailsEl = document.getElementById('imageLoadDetails');
    
    if (progressEl && imageLoadStats.total > 0) {
        const percentage = Math.round((imageLoadStats.loaded + imageLoadStats.failed + imageLoadStats.cached) / imageLoadStats.total * 100);
        const completed = imageLoadStats.loaded + imageLoadStats.failed + imageLoadStats.cached;
        progressEl.textContent = `Loaded: ${completed} / ${imageLoadStats.total} (${percentage}%)`;
    } else if (progressEl) {
        progressEl.textContent = 'No images loaded yet';
    }
    
    if (detailsEl) {
        detailsEl.textContent = `Cache hits: ${imageLoadStats.cached} | Errors: ${imageLoadStats.failed}`;
    }
}

// Preload all coaster images in background
// Update loading screen progress
    function updateLoadingScreen(loaded, total, failed, customMessage = null) {
        requestAnimationFrame(() => {
            const overlay = document.getElementById('imageLoadingOverlay');
            const train = document.getElementById('coasterTrain');
            const progressText = document.getElementById('loadingProgressText');
    
    if (!overlay || !train || !progressText) return;
    
    const processed = loaded + failed;
    const percentage = total > 0 ? Math.round((processed / total) * 100) : 0;
    
    // Move train horizontally across the track
    const container = train.parentElement;
    const maxPosition = container ? container.offsetWidth - 60 : 340; // Leave space for train length
    train.style.left = `${(percentage / 100) * maxPosition}px`;
    
    if (customMessage) {
        progressText.textContent = `${customMessage} (${processed}/${total})`;
    } else {
        progressText.textContent = `Loading images: ${loaded} found, ${failed} not found (${processed}/${total})`;
    }
        });
    }

// Hide loading screen
function hideLoadingScreen() {
    const overlay = document.getElementById('imageLoadingOverlay');
    if (overlay) {
        overlay.classList.add('hidden');
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 300);
    }
}

// Progressive loading: load priority coasters first, then background load rest
// Preload all coaster images during loading screen
async function preloadAllCoasterImages() {
    if (!currentUser || !coasters || coasters.length === 0) {
        hideLoadingScreen();
        return;
    }
    
    cleanOldCacheVersions();
    
    imageLoadStats.loaded = 0;
    imageLoadStats.failed = 0;
    imageLoadStats.cached = 0;
    imageLoadStats.total = coasters.length;
    
    // Quick check: count how many are already cached
    let cachedCount = 0;
    for (const coaster of coasters) {
        const normalizedName = normalizeCoasterName(coaster.naam);
        const normalizedPark = normalizeCoasterName(coaster.park);
        const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
        if (localStorage.getItem(cacheKey)) {
            cachedCount++;
        }
    }
    
    console.log(`üì¶ Found ${cachedCount}/${coasters.length} images in cache`);
    
    // If all are cached, load instantly without showing loading screen progress
    if (cachedCount === coasters.length) {
        console.log(`‚úì All images cached - instant load!`);
        // Just increment stats for cached images
        for (const coaster of coasters) {
            await getCoasterImage(coaster); // Will return from cache instantly
        }
        hideLoadingScreen();
        return;
    }
    
    // Some images need fetching - show loading screen
    updateImageLoadStats();
    updateLoadingScreen(0, coasters.length, 0);
    
    console.log(`üöÄ Loading ${coasters.length - cachedCount} new images (${cachedCount} from cache)...`);
    
    // Load in small batches to avoid rate limiting
    const batchSize = 5;
    const batchDelay = 300; // 300ms between batches
    
    for (let i = 0; i < coasters.length; i += batchSize) {
        const batch = coasters.slice(i, i + batchSize);
        
        await Promise.all(
            batch.map(coaster => 
                getCoasterImage(coaster).then(() => {
                    updateImageLoadStats();
                    updateLoadingScreen(imageLoadStats.loaded, imageLoadStats.total, imageLoadStats.failed);
                })
            )
        );
        
        // Wait between batches only if fetching new images
        if (i + batchSize < coasters.length) {
            await new Promise(resolve => setTimeout(resolve, batchDelay));
        }
    }
    
    console.log(`‚úì All ${coasters.length} coasters loaded!`);
    console.log(`  Loaded: ${imageLoadStats.loaded}, Failed: ${imageLoadStats.failed}, From cache: ${imageLoadStats.cached}`);
    
    hideLoadingScreen();
}

// OLD: Progressive loading function (removed - kept for reference)
async function preloadCoasterImagesProgressive() {
    if (!currentUser || !coasters || coasters.length === 0) {
        hideLoadingScreen();
        return;
    }
    
    cleanOldCacheVersions();
    
    imageLoadStats.loaded = 0;
    imageLoadStats.failed = 0;
    imageLoadStats.cached = 0;
    imageLoadStats.total = coasters.length;
    
    updateImageLoadStats();
    updateLoadingScreen(0, coasters.length, 0);
    
    console.log(`üöÄ Progressive loading: Loading first 20 coasters immediately...`);
    
    // PRIORITY: Load first 20 coasters that will show in initial battles
    const priorityCount = Math.min(20, coasters.length);
    const priorityCoasters = coasters.slice(0, priorityCount);
    
    // Load priority coasters with minimal delay
    for (const coaster of priorityCoasters) {
        await getCoasterImage(coaster);
        coastersWithImages.add(coaster.naam); // Track as loaded
        updateImageLoadStats();
        updateLoadingScreen(imageLoadStats.loaded, imageLoadStats.total, imageLoadStats.failed);
        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay to avoid instant rate limit
    }
    
    console.log(`‚úì First ${priorityCount} coasters loaded - starting battles!`);
    hideLoadingScreen();
    
    // BACKGROUND: Load remaining coasters slowly to avoid rate limits
    if (coasters.length > priorityCount) {
        console.log(`üì¶ Background loading remaining ${coasters.length - priorityCount} coasters...`);
        backgroundLoadRemainingImages(priorityCount);
    }
}

// Background loader - loads remaining images slowly without blocking UI
async function backgroundLoadRemainingImages(startIndex) {
    const remainingCoasters = coasters.slice(startIndex);
    const batchSize = 5; // Balanced batch size for speed without rate limiting
    const batchDelay = 800; // 800ms delay - completes ~100 coasters in under 1 minute
    
    for (let i = 0; i < remainingCoasters.length; i += batchSize) {
        const batch = remainingCoasters.slice(i, i + batchSize);
        
        // Process batch
        await Promise.all(
            batch.map(async (coaster) => {
                await getCoasterImage(coaster);
                coastersWithImages.add(coaster.naam); // Track as loaded
                // Silently update stats without UI noise
            })
        );
        
        // Wait between batches to avoid rate limiting
        if (i + batchSize < remainingCoasters.length) {
            await new Promise(resolve => setTimeout(resolve, batchDelay));
        }
    }
    
    allCoastersLoadingComplete = true;
    console.log(`‚úì Background loading complete - all ${coasters.length} coasters ready! Returning to normal selection.`);
}

// Original full preload function (kept for fallback/manual use)
async function preloadCoasterImages() {
    if (!currentUser || !coasters || coasters.length === 0) {
        hideLoadingScreen();
        return;
    }
    
    // Auto-clean old cache versions before starting
    cleanOldCacheVersions();
    
    // IMPORTANT: Reset ALL stats including cached to avoid showing stale numbers
    imageLoadStats.loaded = 0;
    imageLoadStats.failed = 0;
    imageLoadStats.cached = 0;
    imageLoadStats.total = coasters.length;
    
    updateImageLoadStats();
    updateLoadingScreen(0, coasters.length, 0);
    
    console.log(`Starting image preload for ${coasters.length} coasters...`);
    
    // Track failed coasters for second round
    const failedCoasters = [];
    
    // Smaller batches to avoid overwhelming the API
    const batchSize = 5; // Reduced to avoid rate limiting
    const delay = 300; // Increased delay between batches
    
    // FIRST ROUND: Standard search
    for (let i = 0; i < coasters.length; i += batchSize) {
        const batch = coasters.slice(i, i + batchSize);
        const startCached = imageLoadStats.cached;
        const startFailed = imageLoadStats.failed;
        
        // Process batch in parallel
        await Promise.all(
            batch.map(async (coaster) => {
                await getCoasterImage(coaster);
                updateImageLoadStats();
                updateLoadingScreen(imageLoadStats.loaded, imageLoadStats.total, imageLoadStats.failed);
            })
        );
        
        // Track which coasters in this batch failed
        const newFailures = imageLoadStats.failed - startFailed;
        if (newFailures > 0) {
            // Check which ones failed and add to retry list
            for (const coaster of batch) {
                const normalizedName = normalizeCoasterName(coaster.naam);
                const normalizedPark = normalizeCoasterName(coaster.park);
                const cacheKey = `coasterImage_${CACHE_VERSION}_${normalizedName}_${normalizedPark}`;
                const cached = localStorage.getItem(cacheKey);
                // If it's a placeholder, mark for retry
                if (cached && cached.includes('data:image/svg+xml')) {
                    failedCoasters.push(coaster);
                }
            }
        }
        
        // Only delay if this batch made API calls (not all cached)
        const newlyCached = imageLoadStats.cached - startCached;
        if (i + batchSize < coasters.length && newlyCached < batch.length) {
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    
    const firstRoundSuccess = imageLoadStats.loaded;
    const firstRoundFailed = imageLoadStats.failed;
    console.log(`First round complete: ${firstRoundSuccess} found, ${firstRoundFailed} failed`);
    
    // SECOND ROUND: Enhanced search for failed coasters with park+name combined query
    if (failedCoasters.length > 0) {
        console.log(`üîÑ Starting second round for ${failedCoasters.length} failed coasters...`);
        updateLoadingScreen(imageLoadStats.loaded, imageLoadStats.total, imageLoadStats.failed, 'Retrying failed images...');
        
        let secondRoundSuccess = 0;
        
        for (let i = 0; i < failedCoasters.length; i += batchSize) {
            const batch = failedCoasters.slice(i, i + batchSize);
            
            await Promise.all(
                batch.map(async (coaster) => {
                    const result = await enhancedCoasterImageSearch(coaster);
                    if (result) {
                        secondRoundSuccess++;
                        imageLoadStats.loaded++;
                        imageLoadStats.failed--;
                        updateImageLoadStats();
                        updateLoadingScreen(imageLoadStats.loaded, imageLoadStats.total, imageLoadStats.failed);
                    }
                })
            );
            
            // Delay between batches
            if (i + batchSize < failedCoasters.length) {
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        console.log(`Second round complete: ${secondRoundSuccess} additional images found`);
    }
    
    const successRate = Math.round((imageLoadStats.loaded / imageLoadStats.total) * 100);
    console.info(`Image preloading complete: ${successRate}% success (${imageLoadStats.loaded} found, ${imageLoadStats.failed} not found, ${imageLoadStats.cached} cached)`, imageLoadStats);
    
    // Hide loading screen after all images are processed
    hideLoadingScreen();
}

// ========================================
// END IMAGE FETCHING SERVICE
// ========================================
    
    function syncSimInputWidth() {
        try {
            const btn = DOM.simulateBtn || $id('simulateBtn');
            const input = DOM.simulateCount || $id('simulateCount');
            if (btn && input) {
                const w = btn.offsetWidth;
                // use box-sizing aware width
                input.style.width = w + 'px';
            }
        } catch (e) { /* ignore */ }
    }

// Consolidated debounced resize handler (handles header, sim input and dev-data positioning)
const onResize = debounce(() => {
    setHeaderHeight();
    syncSimInputWidth();
    if (devShowData) {
        renderDevData();
        setTimeout(positionDevData, 0);
    }
}, 120);

window.addEventListener('resize', onResize, { passive: true });
    let currentUser = null;
    let coasters = [];
    let coastersWithImages = new Set(); // Track coasters that have images loaded
    let allCoastersLoadingComplete = false; // True when all coasters have been attempted
    let coasterStats = {};
    let totalBattlesCount = 0;
    let currentBattle = null;
    let closeIntroTimeout = null; // handle for scheduled close-intro so we can cancel it
    let closeIntroActive = false; // true while the intro animation is running
    let resolvingBattle = false; // true while a winner choice is being processed
    let closeIntroPrevVSDisplay = null;

    // Cancel any pending or active close-intro/overlay immediately
    function cancelCloseIntro(){
        try{
            closeIntroActive = false;
            if (closeIntroTimeout) { clearTimeout(closeIntroTimeout); closeIntroTimeout = null; }
            // hide overlay/banner/burst immediately and remove visible classes
            const overlay = document.getElementById('closeBattleOverlay');
            const banner = document.getElementById('closeBanner');
            const burst = document.getElementById('winnerBurst');
            const vs = document.querySelector('.vs-divider');
            if (banner) { banner.classList.remove('show'); banner.style.removeProperty('display'); }
            if (burst) { burst.classList.remove('show','big'); burst.style.removeProperty('display'); }
            if (overlay) {
                overlay.classList.remove('show');
                overlay.style.setProperty('display','none','important');
                overlay.style.setProperty('opacity','0','important');
                overlay.style.removeProperty('z-index');
                overlay.setAttribute('aria-hidden','true');
            }
            // hide the original VS marker while overlay/intro is hidden
            try{ if (vs) { vs.style.setProperty('display','none','important'); vs.setAttribute('data-cr-hidden','true'); } }catch(e){}
            // clear dev force so it doesn't accidentally retrigger after hiding
            try{ devForceCloseBattle = false; }catch(e){}
        }catch(e){ /* swallow */ }
    }

    // Restore the original VS divider (remove any forced hiding)
    function restoreVsDivider(){
        try{
            const vs = document.querySelector('.vs-divider');
            if (!vs) return;
            if (closeIntroPrevVSDisplay !== null && closeIntroPrevVSDisplay !== '') vs.style.display = closeIntroPrevVSDisplay; else vs.style.removeProperty('display');
            vs.removeAttribute('data-cr-hidden');
            // also remove any !important hide if present
            try { vs.style.removeProperty('display'); } catch(e) {}
            closeIntroPrevVSDisplay = null;
        }catch(e){}
    }
    let isProcessingChoice = false;
    let currentSort = { column: 'rating', ascending: false };
    // History: stores past battles for current user
    let coasterHistory = [];
    // Stack for undoing deletions (LIFO)
    let deletedHistoryStack = [];
    const MAX_UNDO_STACK = 50;
    const MAX_HISTORY_KEEP = 10000; // Maximum history entries to keep
    // Exploration boost: favor coasters with few battles
    let EXPLORATION_POWER = 2; // higher => stronger preference for low-battles
    // Glicko-2 rating system parameters
    const GLICKO2_RATING_BASE = 1500;     // Initial rating (same scale as ELO for compatibility)
    const GLICKO2_RD_INITIAL = 350;       // Initial rating deviation (high uncertainty)
    const GLICKO2_VOLATILITY_INITIAL = 0.06; // Initial volatility
    const GLICKO2_TAU = 0.5;              // System constant (constrains volatility change, 0.3-1.2)
    const GLICKO2_EPSILON = 0.000001;     // Convergence tolerance
    const GLICKO2_SCALE_FACTOR = 173.7178; // Conversion factor from Glicko to Glicko-2 scale
    const PRIOR_WEIGHT = 6;  // pseudo-battles pulling displayed rating toward mean (for display only)
    // Rating-proximity: prefer opponents whose rating is similar (more informative matches)
    let RATING_PROXIMITY_POWER = 0.1; // higher => stronger preference for similar rating
    const RATING_DIFF_SCALE = 400; // scale (in rating points) used to normalize differences
    // Pairing strategy: hybrid ‚Äî picks one under-sampled coaster
    // then picks a second that is ELO-similar while still favoring under-sampled ones.
    let pairingControlsHidden = true;
    // Track all completed pairs to prevent duplicates
    let completedPairs = new Set();

    // Dev UI: whether to show debug data beside cards
    let devShowData = false;

// Lightweight DOM cache for frequently used elements (populated on DOMContentLoaded)
const DOM = {};
    function switchUser(user) {
        currentUser = user;
        
        // Update UI
        document.querySelectorAll('.user-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn-' + user).classList.add('active');
        document.getElementById('currentUserBadge').textContent = `Logged in as: ${user === 'luca' ? 'Luca' : 'Wouter'}`;
        
        // Load user-specific data
        if (user === 'luca') {
            coasters = coastersDataLuca.filter(c => c.operatief === 1);
        } else {
            coasters = coastersDataWouter.filter(c => c.operatief === 1);
        }
        
        // Load or initialize stats
        loadUserData();
        
        // Load achievements
        if (typeof achievementManager !== 'undefined') {
            achievementManager.load(user);
            updateAchievementsTab();
        }
        
        // Reset session stats when switching users
        resetSessionStats();
        
        // Refresh displays
        displayBattle();
        updateRanking();
        displayHome(); // Update home tab with new user data
        
        // close menu after selection (if open)
        try { closeUserMenu(); } catch (e) {}
    }

    function loadUserData() {
        const statsKey = `coasterStats_${currentUser}`;
        const battlesKey = `totalBattles_${currentUser}`;
        const historyKey = `coasterHistory_${currentUser}`;
        const pairsKey = `completedPairs_${currentUser}`;
        const battleKey = `currentBattle_${currentUser}`;

        coasterStats = JSON.parse(localStorage.getItem(statsKey)) || initializeStats();
        
        // Migrate from ELO to Glicko-2 if necessary
        Object.values(coasterStats).forEach(stats => {
            if (stats.elo !== undefined && stats.rating === undefined) {
                // Migrate old ELO data to Glicko-2
                stats.rating = stats.elo;
                stats.rd = GLICKO2_RD_INITIAL;
                stats.volatility = GLICKO2_VOLATILITY_INITIAL;
                delete stats.elo;
            }
            // Ensure all Glicko-2 fields exist
            if (stats.rating === undefined) stats.rating = GLICKO2_RATING_BASE;
            if (stats.rd === undefined) stats.rd = GLICKO2_RD_INITIAL;
            if (stats.volatility === undefined) stats.volatility = GLICKO2_VOLATILITY_INITIAL;
        });
        
        totalBattlesCount = parseInt(localStorage.getItem(battlesKey)) || 0;
        coasterHistory = JSON.parse(localStorage.getItem(historyKey)) || [];
        
        // Load completed pairs
        const savedPairs = localStorage.getItem(pairsKey);
        completedPairs = savedPairs ? new Set(JSON.parse(savedPairs)) : new Set();
        
        // Load current battle if it exists
        try {
            const savedBattle = localStorage.getItem(battleKey);
            if (savedBattle) {
                currentBattle = JSON.parse(savedBattle);
            }
        } catch (e) {
            currentBattle = null;
        }
        
        // load pairing settings for this user (if any)
        loadPairingSettings();
        // load developer UI settings for this user
        loadDevSettings();
    }

    function initializeStats() {
        const stats = {};
        coasters.forEach(coaster => {
            stats[coaster.naam] = {
                name: coaster.naam,
                park: coaster.park,
                manufacturer: coaster.fabrikant,
                rating: GLICKO2_RATING_BASE,
                rd: GLICKO2_RD_INITIAL,
                volatility: GLICKO2_VOLATILITY_INITIAL,
                battles: 0,
                wins: 0,
                losses: 0
            };
        });
        return stats;
    }

    function saveData() {
        if (!currentUser) return;
        const statsKey = `coasterStats_${currentUser}`;
        const battlesKey = `totalBattles_${currentUser}`;
        const historyKey = `coasterHistory_${currentUser}`;
        const pairsKey = `completedPairs_${currentUser}`;
        const battleKey = `currentBattle_${currentUser}`;

        try {
            localStorage.setItem(statsKey, JSON.stringify(coasterStats));
            localStorage.setItem(battlesKey, totalBattlesCount.toString());
            localStorage.setItem(historyKey, JSON.stringify(coasterHistory));
            localStorage.setItem(pairsKey, JSON.stringify([...completedPairs]));
            // Save current battle if it exists
            if (currentBattle && currentBattle.length === 2) {
                localStorage.setItem(battleKey, JSON.stringify(currentBattle));
            } else {
                localStorage.removeItem(battleKey);
            }
        } catch (error) {
            // Handle localStorage quota exceeded
            if (error.name === 'QuotaExceededError') {
                console.error('LocalStorage quota exceeded. Consider clearing old data.');
                showToast('Storage limit reached. Some data may not be saved.', 3000);
            } else {
                console.error('Error saving data:', error);
            }
        }
        
        // persist pairing settings per-user
        try {
            const settingsKey = `pairingSettings_${currentUser}`;
            const settings = { explorationPower: EXPLORATION_POWER, eloProximityPower: ELO_PROXIMITY_POWER, pairingControlsHidden: pairingControlsHidden };
            localStorage.setItem(settingsKey, JSON.stringify(settings));
        } catch (e) {
            // ignore
        }
    }

    // Persist/load pairing settings per user
    function loadPairingSettings() {
        if (!currentUser) return;
        try {
            const settingsKey = `pairingSettings_${currentUser}`;
            const raw = localStorage.getItem(settingsKey);
            if (!raw) return applySettingsToUI();
            const s = JSON.parse(raw);
            if (s && typeof s.explorationPower === 'number') EXPLORATION_POWER = s.explorationPower;
            if (s && typeof s.eloProximityPower === 'number') ELO_PROXIMITY_POWER = s.eloProximityPower;
            if (s && typeof s.pairingControlsHidden === 'boolean') pairingControlsHidden = s.pairingControlsHidden;
        } catch (e) {
            // ignore
        }
        applySettingsToUI();
    }

    function setEloProximityPower(val) {
        const num = Number(val);
        if (isNaN(num)) return;
        ELO_PROXIMITY_POWER = num;
        const el = document.getElementById('eloProximityValue');
        if (el) el.textContent = num.toFixed(1);
        saveData();
    }

    function setExplorationPower(val) {
        const num = Number(val);
        if (isNaN(num)) return;
        EXPLORATION_POWER = num;
        const el = document.getElementById('explorationPowerValue');
        if (el) el.textContent = num.toFixed(1);
        saveData();
    }

    function applySettingsToUI() {
        // update range and label for exploration power
        const expRange = document.getElementById('explorationPowerRange');
        const expVal = document.getElementById('explorationPowerValue');
        if (expRange) expRange.value = EXPLORATION_POWER;
        if (expVal) expVal.textContent = (Number(EXPLORATION_POWER) || 0).toFixed(1);
        
        // update range and label for elo proximity
        const range = document.getElementById('eloProximityRange');
        const val = document.getElementById('eloProximityValue');
        if (range) range.value = ELO_PROXIMITY_POWER;
        if (val) val.textContent = (Number(ELO_PROXIMITY_POWER) || 0).toFixed(1);
        // apply pairing controls hidden state
        const pairingDiv = document.getElementById('pairingControls');
        const toggleBtn = document.getElementById('pairingControlsToggle');
        if (pairingDiv) {
            if (pairingControlsHidden) pairingDiv.classList.add('collapsed'); else pairingDiv.classList.remove('collapsed');
        }
        if (toggleBtn) {
            if (pairingControlsHidden) {
                toggleBtn.classList.add('collapsed');
                toggleBtn.setAttribute('aria-expanded', 'false');
                toggleBtn.title = 'Toon instellingen';
            } else {
                toggleBtn.classList.remove('collapsed');
                toggleBtn.setAttribute('aria-expanded', 'true');
                toggleBtn.title = 'Verberg instellingen';
            }
        }
    }

    function togglePairingControls() {
        pairingControlsHidden = !pairingControlsHidden;
        applySettingsToUI();
        saveData();
    }

    // Developer UI settings (per-user)
    function toggleDevData() {
        // toggle state directly (do not refresh the current battle)
        devShowData = !devShowData;
        saveDevSettings();
        const btn = document.getElementById('devToggleDataBtn');
        if (btn) {
            if (devShowData) { btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true'); } else { btn.classList.remove('active'); btn.setAttribute('aria-pressed', 'false'); }
        }
        renderDevData();
    }

    function saveDevSettings() {
        if (!currentUser) return;
        localStorage.setItem(`devShowData_${currentUser}`, JSON.stringify(devShowData));
    }

    function loadDevSettings() {
        if (!currentUser) return;
        try {
            const raw = localStorage.getItem(`devShowData_${currentUser}`);
            devShowData = raw ? JSON.parse(raw) : false;
        } catch (e) { devShowData = false; }
        const btn = document.getElementById('devToggleDataBtn');
        if (btn) {
            if (devShowData) { btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true'); } else { btn.classList.remove('active'); btn.setAttribute('aria-pressed', 'false'); }
        }
    }

    function resetAllUserData() {
        if (!currentUser) return;
        const ok = confirm('Are you sure? This will delete rankings, history and pairing progress for the user.');
        if (!ok) return;
        coasterStats = initializeStats();
        totalBattlesCount = 0;
        coasterHistory = [];
        completedPairs = new Set();
        saveData();
        updateRanking();
        displayHistory();
        displayBattle();
        showToast('‚úÖ Data reset for ' + currentUser);
    }

    // Export all user data as a downloadable JSON file
    function exportUserData() {
        if (!currentUser) {
            showToast('‚ö†Ô∏è Please select a user first');
            return;
        }

        try {
            // Collect all relevant data for the current user
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                user: currentUser,
                data: {
                    coasterStats: coasterStats,
                    totalBattlesCount: totalBattlesCount,
                    coasterHistory: coasterHistory,
                    completedPairs: [...completedPairs],
                    pairingSettings: {
                        explorationPower: EXPLORATION_POWER,
                        eloProximityPower: ELO_PROXIMITY_POWER,
                        pairingControlsHidden: pairingControlsHidden
                    },
                    closeBattleCounters: {
                        counter: localStorage.getItem(CR_STORAGE_COUNTER) || '0',
                        threshold: localStorage.getItem(CR_STORAGE_THRESHOLD) || '25'
                    },
                    achievements: {
                        unlocked: typeof achievementManager !== 'undefined' 
                            ? Object.fromEntries(achievementManager.unlockedAchievements)
                            : {},
                        stats: {
                            leftStreak: typeof achievementManager !== 'undefined' ? achievementManager.leftStreak : 0,
                            rightStreak: typeof achievementManager !== 'undefined' ? achievementManager.rightStreak : 0,
                            perfectMatches: typeof achievementManager !== 'undefined' ? achievementManager.perfectMatches : 0,
                            closeFights: typeof achievementManager !== 'undefined' ? achievementManager.closeFights : 0,
                            sessionBattles: typeof achievementManager !== 'undefined' ? achievementManager.sessionBattles : 0,
                            lastBattleDate: typeof achievementManager !== 'undefined' ? achievementManager.lastBattleDate : null,
                            consecutiveDays: typeof achievementManager !== 'undefined' ? achievementManager.consecutiveDays : 0,
                            dailyBattleDates: typeof achievementManager !== 'undefined' ? [...achievementManager.dailyBattleDates] : []
                        }
                    }
                }
            };

            // Convert to JSON string
            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Create a blob and download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `coaster-ranker-${currentUser}-${new Date().toISOString().split('T')[0]}.json`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            // Track export for achievements
            if (typeof achievementManager !== 'undefined') {
                achievementManager.recordExport();
                checkAndShowAchievements();
            }
            
            showToast(`‚úÖ Data exported for ${currentUser}`);
        } catch (error) {
            console.error('Export failed:', error);
            showToast('‚ùå Export failed. Check console for details.');
        }
    }

    // Import user data from a JSON file
    function importUserData(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Reset the file input so the same file can be selected again
        event.target.value = '';

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importData = JSON.parse(e.target.result);
                
                // Validate the import data structure
                if (!importData.version || !importData.data) {
                    throw new Error('Invalid file format');
                }

                // Confirm import (especially if different user)
                const importUser = importData.user || 'unknown';
                const confirmMessage = currentUser 
                    ? `Import data for user "${importUser}"?\n\nThis will overwrite all current data for ${currentUser}.`
                    : `Import data for user "${importUser}"?`;
                
                if (!confirm(confirmMessage)) {
                    showToast('‚ùå Import cancelled');
                    return;
                }

                // If no user selected, switch to the imported user
                if (!currentUser && importUser) {
                    switchUser(importUser);
                }

                // Restore the data
                const data = importData.data;
                
                if (data.coasterStats) coasterStats = data.coasterStats;
                if (typeof data.totalBattlesCount === 'number') totalBattlesCount = data.totalBattlesCount;
                if (Array.isArray(data.coasterHistory)) coasterHistory = data.coasterHistory;
                if (Array.isArray(data.completedPairs)) completedPairs = new Set(data.completedPairs);
                
                // Restore settings
                if (data.pairingSettings) {
                    if (typeof data.pairingSettings.explorationPower === 'number') EXPLORATION_POWER = data.pairingSettings.explorationPower;
                    if (typeof data.pairingSettings.eloProximityPower === 'number') ELO_PROXIMITY_POWER = data.pairingSettings.eloProximityPower;
                    if (typeof data.pairingSettings.pairingControlsHidden === 'boolean') pairingControlsHidden = data.pairingSettings.pairingControlsHidden;
                }

                // Restore close battle counters
                if (data.closeBattleCounters) {
                    localStorage.setItem(CR_STORAGE_COUNTER, data.closeBattleCounters.counter || '0');
                    localStorage.setItem(CR_STORAGE_THRESHOLD, data.closeBattleCounters.threshold || '25');
                }

                // Restore achievements
                if (data.achievements && typeof achievementManager !== 'undefined') {
                    // Restore unlocked achievements
                    if (data.achievements.unlocked) {
                        achievementManager.unlockedAchievements = new Map(Object.entries(data.achievements.unlocked));
                    }
                    
                    // Restore achievement stats
                    if (data.achievements.stats) {
                        const stats = data.achievements.stats;
                        achievementManager.leftStreak = stats.leftStreak || 0;
                        achievementManager.rightStreak = stats.rightStreak || 0;
                        achievementManager.perfectMatches = stats.perfectMatches || 0;
                        achievementManager.closeFights = stats.closeFights || 0;
                        achievementManager.sessionBattles = stats.sessionBattles || 0;
                        achievementManager.lastBattleDate = stats.lastBattleDate || null;
                        achievementManager.consecutiveDays = stats.consecutiveDays || 0;
                        achievementManager.dailyBattleDates = new Set(stats.dailyBattleDates || []);
                    }
                    
                    achievementManager.save(currentUser);
                }

                // Save to localStorage
                saveData();
                
                // Refresh UI
                updateRanking();
                displayHistory();
                displayBattle();
                applySettingsToUI();
                updateAchievementsTab();
                
                showToast(`‚úÖ Data imported successfully for ${importUser}`);
            } catch (error) {
                console.error('Import failed:', error);
                showToast('‚ùå Import failed. Invalid file or corrupted data.');
            }
        };
        
        reader.onerror = function() {
            showToast('‚ùå Failed to read file');
        };
        
        reader.readAsText(file);
    }

    // User menu (hamburger) toggle and outside-click handling
    function toggleUserMenu() {
        const menu = document.getElementById('userMenu');
        const btn = document.getElementById('userMenuToggle');
        if (!menu || !btn) return;
        const open = menu.classList.toggle('open');
        menu.setAttribute('aria-hidden', (!open).toString());
        btn.setAttribute('aria-expanded', open.toString());
        if (open) {
            // attach a one-time outside click listener
            setTimeout(() => {
                document.addEventListener('click', outsideClickHandler);
            }, 0);
        } else {
            document.removeEventListener('click', outsideClickHandler);
        }
    }

    function closeUserMenu() {
        const menu = document.getElementById('userMenu');
        const btn = document.getElementById('userMenuToggle');
        if (!menu || !btn) return;
        menu.classList.remove('open');
        menu.setAttribute('aria-hidden', 'true');
        btn.setAttribute('aria-expanded', 'false');
        document.removeEventListener('click', outsideClickHandler);
    }

    function outsideClickHandler(ev) {
        const menu = document.getElementById('userMenu');
        const btn = document.getElementById('userMenuToggle');
        if (!menu || !btn) return;
        if (!menu.contains(ev.target) && ev.target !== btn) {
            closeUserMenu();
        }
    }

    // Developer menu (bottom-left) toggle and outside-click handling
    function toggleDevMenu() {
        const menu = $id('devMenu');
        const btn = $id('devToggleBtn');
        if (!menu || !btn) return;
        const open = menu.classList.toggle('open');
        menu.setAttribute('aria-hidden', (!open).toString());
        btn.setAttribute('aria-expanded', open.toString());
        if (open) {
            document.addEventListener('click', devOutsideClickHandler);
            // sync the simulate input width when menu opens; use rAF to avoid layout thrash
            try {
                requestAnimationFrame(() => {
                    try { syncSimInputWidth(); } catch (e) {}
                    requestAnimationFrame(() => { try { syncSimInputWidth(); } catch (e) {} });
                });
            } catch (e) { /* ignore */ }
        } else {
            document.removeEventListener('click', devOutsideClickHandler);
        }
    }

    function closeDevMenu() {
        const menu = document.getElementById('devMenu');
        const btn = document.getElementById('devToggleBtn');
        if (!menu || !btn) return;
        menu.classList.remove('open');
        menu.setAttribute('aria-hidden', 'true');
        btn.setAttribute('aria-expanded', 'false');
        document.removeEventListener('click', devOutsideClickHandler);
    }

    function devOutsideClickHandler(ev) {
        const menu = document.getElementById('devMenu');
        const btn = document.getElementById('devToggleBtn');
        if (!menu || !btn) return;
        if (!menu.contains(ev.target) && !btn.contains(ev.target)) {
            closeDevMenu();
        }
    }

    // Simulation: simulate X battles for the current user (updates ELO, history, rankings)
    async function simulateBattlesFromUI() {
        const input = document.getElementById('simulateCount');
        const btn = document.getElementById('simulateBtn');
        if (!input || !btn) return;
        const count = parseInt(input.value, 10);
        if (!currentUser) { showToast('Select a user first'); return; }
        if (isNaN(count) || count <= 0) { showToast('Enter a valid number (‚â•1)'); return; }
        btn.disabled = true;
        try {
            const result = await simulateBattles(count, (progress, total) => {
                const el = document.getElementById('simulateProgress');
                if (el) { el.style.display = 'block'; el.textContent = `Progress: ${progress} / ${total}`; }
            });
            showToast(`‚úÖ Simulated: ${result} battles`);
        } catch (e) {
            showToast('Simulation error');
            console.error(e);
        } finally {
            const el = document.getElementById('simulateProgress'); if (el) el.style.display = 'none';
            btn.disabled = false;
            // refresh UI
            updateRanking();
            displayHistory();
            displayBattle();
        }
    }

    async function simulateBattles(count, progressCallback) {
        if (!currentUser) throw new Error('No user selected');
        let simulated = 0;
        // process in small batches to keep UI responsive
        const batchSize = 200;
        try {
            for (let offset = 0; offset < count; offset += batchSize) {
                const end = Math.min(count, offset + batchSize);
                for (let i = offset; i < end; i++) {
                    const pair = getRandomCoasters();
                    if (!pair) {
                        // no more unique pairs available
                        return simulated;
                    }

                    // pick winner probabilistically according to current ratings (using Glicko-2)
                    const a = pair[0], b = pair[1];
                    // ensure stats exist for both coasters
                    const aStats = ensureCoasterStats(a);
                    const bStats = ensureCoasterStats(b);
                    // Calculate win probability using Glicko-2 expected score
                    const mu_a = glicko2Scale(aStats.rating);
                    const phi_a = glicko2ScaleRD(aStats.rd);
                    const mu_b = glicko2Scale(bStats.rating);
                    const phi_b = glicko2ScaleRD(bStats.rd);
                    const probA = glicko2_E(mu_a, mu_b, phi_b);
                    const rnd = (typeof rng === 'function') ? rng() : Math.random();
                    const winnerIdx = (rnd < probA) ? 0 : 1;
                    const winner = pair[winnerIdx], loser = pair[1 - winnerIdx];

                    // update stats
                    const winnerStats = ensureCoasterStats(winner);
                    const loserStats = ensureCoasterStats(loser);
                    
                    // Capture data before battle
                    const winnerRatingBefore = winnerStats.rating;
                    const loserRatingBefore = loserStats.rating;
                    const winnerRDBefore = winnerStats.rd;
                    const loserRDBefore = loserStats.rd;
                    const winnerVolatilityBefore = winnerStats.volatility;
                    const loserVolatilityBefore = loserStats.volatility;
                    const winnerRankBefore = getCoasterRank(winner.naam);
                    const loserRankBefore = getCoasterRank(loser.naam);
                    const winnerBattlesBefore = winnerStats.battles;
                    const loserBattlesBefore = loserStats.battles;
                    
                    const glickoOutcome = calculateGlicko2(winnerStats, loserStats);
                    const { newWinnerRating, newWinnerRD, newWinnerVolatility, newLoserRating, newLoserRD, newLoserVolatility } = glickoOutcome;
                    
                    // Calculate expected probabilities and potential changes
                    const mu_w = glicko2Scale(winnerRatingBefore);
                    const phi_w = glicko2ScaleRD(winnerRDBefore);
                    const mu_l = glicko2Scale(loserRatingBefore);
                    const phi_l = glicko2ScaleRD(loserRDBefore);
                    const expectedWinnerProb = glicko2_E(mu_w, mu_l, phi_l);
                    const expectedLoserProb = 1 - expectedWinnerProb;
                    const winnerPotentialGain = newWinnerRating - winnerRatingBefore;
                    const loserPotentialLoss = newLoserRating - loserRatingBefore;
                    const loserIfWinOutcome = calculateGlicko2(loserStats, winnerStats);
                    const loserPotentialGain = loserIfWinOutcome.newWinnerRating - loserRatingBefore;
                    const winnerPotentialLoss = loserIfWinOutcome.newLoserRating - winnerRatingBefore;
                    
                    winnerStats.rating = newWinnerRating; winnerStats.rd = newWinnerRD; winnerStats.volatility = newWinnerVolatility;
                    winnerStats.battles++; winnerStats.wins++;
                    loserStats.rating = newLoserRating; loserStats.rd = newLoserRD; loserStats.volatility = newLoserVolatility;
                    loserStats.battles++; loserStats.losses++;
                    totalBattlesCount++;
                    
                    // Get ranks after battle
                    const winnerRankAfter = getCoasterRank(winner.naam);
                    const loserRankAfter = getCoasterRank(loser.naam);
                    const wasCloseMatch = Math.abs(winnerRankBefore - loserRankBefore) < 3;
                    
                    // Build comprehensive battle stats
                    const battleStats = {
                        statsA: {
                            ratingBefore: (pair[0].naam === winner.naam) ? winnerRatingBefore : loserRatingBefore,
                            ratingAfter: (pair[0].naam === winner.naam) ? winnerStats.rating : loserStats.rating,
                            rdBefore: (pair[0].naam === winner.naam) ? winnerRDBefore : loserRDBefore,
                            rdAfter: (pair[0].naam === winner.naam) ? winnerStats.rd : loserStats.rd,
                            volatilityBefore: (pair[0].naam === winner.naam) ? winnerVolatilityBefore : loserVolatilityBefore,
                            volatilityAfter: (pair[0].naam === winner.naam) ? winnerStats.volatility : loserStats.volatility,
                            potentialGain: (pair[0].naam === winner.naam) ? winnerPotentialGain : loserPotentialGain,
                            potentialLoss: (pair[0].naam === winner.naam) ? winnerPotentialLoss : loserPotentialLoss,
                            rankBefore: (pair[0].naam === winner.naam) ? winnerRankBefore : loserRankBefore,
                            rankAfter: (pair[0].naam === winner.naam) ? winnerRankAfter : loserRankAfter,
                            expectedWinProbability: (pair[0].naam === winner.naam) ? expectedWinnerProb : expectedLoserProb,
                            totalBattlesBefore: (pair[0].naam === winner.naam) ? winnerBattlesBefore : loserBattlesBefore
                        },
                        statsB: {
                            ratingBefore: (pair[1].naam === winner.naam) ? winnerRatingBefore : loserRatingBefore,
                            ratingAfter: (pair[1].naam === winner.naam) ? winnerStats.rating : loserStats.rating,
                            rdBefore: (pair[1].naam === winner.naam) ? winnerRDBefore : loserRDBefore,
                            rdAfter: (pair[1].naam === winner.naam) ? winnerStats.rd : loserStats.rd,
                            volatilityBefore: (pair[1].naam === winner.naam) ? winnerVolatilityBefore : loserVolatilityBefore,
                            volatilityAfter: (pair[1].naam === winner.naam) ? winnerStats.volatility : loserStats.volatility,
                            potentialGain: (pair[1].naam === winner.naam) ? winnerPotentialGain : loserPotentialGain,
                            potentialLoss: (pair[1].naam === winner.naam) ? winnerPotentialLoss : loserPotentialLoss,
                            rankBefore: (pair[1].naam === winner.naam) ? winnerRankBefore : loserRankBefore,
                            rankAfter: (pair[1].naam === winner.naam) ? winnerRankAfter : loserRankAfter,
                            expectedWinProbability: (pair[1].naam === winner.naam) ? expectedWinnerProb : expectedLoserProb,
                            totalBattlesBefore: (pair[1].naam === winner.naam) ? winnerBattlesBefore : loserBattlesBefore
                        },
                        closeFight: wasCloseMatch
                    };

                    // record battle (keeps completedPairs) ‚Äî skip immediate save to batch at the end
                    recordBattle(pair[0], pair[1], winner.naam, loser.naam, { skipSave: true, battleStats });

                    simulated++;
                    if (progressCallback && (simulated % 10 === 0)) progressCallback(simulated, count);
                }
                // yield to event loop between batches
                await new Promise(r => setTimeout(r, 0));
            }
        } finally {
            // ensure we persist progress even if an error occurs mid-run
            try { saveData(); } catch (e) { /* ignore save errors */ }
        }
        return simulated;
    }

    // Render or remove dev-data overlays based on currentBattle and viewport
    function renderDevData() {
        const battleContainer = DOM.battleContainer || $id('battleContainer');
        if (!battleContainer) return;
        // remove existing overlays
        battleContainer.querySelectorAll('.dev-data-overlay').forEach(n => n.remove());

        if (!devShowData) return;
        if (!currentBattle || currentBattle.length < 2) return;

        // compute the same dev-html used when battle is first rendered
        const left = currentBattle[0], right = currentBattle[1];
        const leftStats = coasterStats[left.naam] || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };
        const rightStats = coasterStats[right.naam] || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };
        // compute Glicko-2 scenarios once
        const leftIfWin = calculateGlicko2(leftStats, rightStats);
        const leftIfLose = calculateGlicko2(rightStats, leftStats);
        const leftGainWin = Math.round(leftIfWin.newWinnerRating - leftStats.rating);
        const leftLoseIfLose = Math.round(leftIfLose.newLoserRating - leftStats.rating);
        const rightGainWin = Math.round(leftIfLose.newWinnerRating - rightStats.rating);
        const rightLoseIfLose = Math.round(leftIfWin.newLoserRating - rightStats.rating);
        const fmt = (n) => (n >= 0 ? '+' + n : n.toString());

        const rank1 = (() => { const statsArray = Object.values(coasterStats); const sorted = [...statsArray].sort((a, b) => b.rating - a.rating); return sorted.findIndex(c => c.name === left.naam) + 1; })();
        const rank2 = (() => { const statsArray = Object.values(coasterStats); const sorted = [...statsArray].sort((a, b) => b.rating - a.rating); return sorted.findIndex(c => c.name === right.naam) + 1; })();

        const devLeftHtml = `
            <div><strong>Rank:</strong> ${rank1}</div>
            <div><strong>Rating:</strong> ${Math.round(leftStats.rating)} ¬± ${Math.round(leftStats.rd)}</div>
            <div><strong>œÉ:</strong> ${leftStats.volatility.toFixed(4)}</div>
            <div><strong>Œî (win):</strong> ${fmt(leftGainWin)}</div>
            <div><strong>Œî (lose):</strong> ${fmt(leftLoseIfLose)}</div>
            <div><strong>Battles:</strong> ${leftStats.battles}</div>
            <div><strong>Wins:</strong> ${leftStats.wins}</div>
            <div><strong>Losses:</strong> ${leftStats.losses}</div>
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.2);">
                <div id="imageInfo_${left.naam.replace(/[^a-z0-9]/gi, '_')}" style="font-size:0.85em;color:#aaa;margin-bottom:4px;"></div>
                <button onclick="retryCoasterImage('${left.naam.replace(/'/g, "\\'")}', '${left.park.replace(/'/g, "\\'")}', '${left.fabrikant.replace(/'/g, "\\'")}', '${left.naam.replace(/[^a-z0-9]/gi, '_')}', event)" style="font-size:0.85em;padding:2px 6px;background:#4CA1AF;color:white;border:none;border-radius:4px;cursor:pointer;">üîÑ Retry Image</button>
            </div>
        `;
        const devRightHtml = `
            <div><strong>Rank:</strong> ${rank2}</div>
            <div><strong>Rating:</strong> ${Math.round(rightStats.rating)} ¬± ${Math.round(rightStats.rd)}</div>
            <div><strong>œÉ:</strong> ${rightStats.volatility.toFixed(4)}</div>
            <div><strong>Œî (win):</strong> ${fmt(rightGainWin)}</div>
            <div><strong>Œî (lose):</strong> ${fmt(rightLoseIfLose)}</div>
            <div><strong>Battles:</strong> ${rightStats.battles}</div>
            <div><strong>Wins:</strong> ${rightStats.wins}</div>
            <div><strong>Losses:</strong> ${rightStats.losses}</div>
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.2);">
                <div id="imageInfo_${right.naam.replace(/[^a-z0-9]/gi, '_')}" style="font-size:0.85em;color:#aaa;margin-bottom:4px;"></div>
                <button onclick="retryCoasterImage('${right.naam.replace(/'/g, "\\'")}', '${right.park.replace(/'/g, "\\'")}', '${right.fabrikant.replace(/'/g, "\\'")}', '${right.naam.replace(/[^a-z0-9]/gi, '_')}', event)" style="font-size:0.85em;padding:2px 6px;background:#4CA1AF;color:white;border:none;border-radius:4px;cursor:pointer;">üîÑ Retry Image</button>
            </div>
        `;

        // Place overlay inside coaster cards, over the images
        const cards = battleContainer.querySelectorAll('.coaster-card');
        if (cards[0]) {
            const leftOverlay = document.createElement('div');
            leftOverlay.className = 'dev-data-overlay';
            leftOverlay.innerHTML = devLeftHtml;
            cards[0].appendChild(leftOverlay);
        }
        if (cards[1]) {
            const rightOverlay = document.createElement('div');
            rightOverlay.className = 'dev-data-overlay';
            rightOverlay.innerHTML = devRightHtml;
            cards[1].appendChild(rightOverlay);
        }
    }

    // Position dev-data boxes next to the cards (desktop) or inline (mobile)
    function positionDevData() {
        const battleContainer = DOM.battleContainer || $id('battleContainer');
        if (!battleContainer) return;
        const leftCard = battleContainer.querySelector('.coaster-card.left-card');
        const rightCard = battleContainer.querySelector('.coaster-card.right-card');
        const leftBox = battleContainer.querySelector('.dev-data-side.left');
        const rightBox = battleContainer.querySelector('.dev-data-side.right');
        if (!leftCard || !rightCard || !leftBox || !rightBox) return;

        // compute positions relative to container
        const containerRect = battleContainer.getBoundingClientRect();
        const leftRect = leftCard.getBoundingClientRect();
        const rightRect = rightCard.getBoundingClientRect();

        // left box: place to the left of the left card
        const leftTop = leftRect.top - containerRect.top + (leftRect.height - leftBox.offsetHeight) / 2;
        const leftLeft = leftRect.left - containerRect.left - leftBox.offsetWidth - 12; // 12px gap
        leftBox.style.top = Math.max(4, leftTop) + 'px';
        leftBox.style.left = leftLeft + 'px';

        // right box: place to the right of the right card
        const rightTop = rightRect.top - containerRect.top + (rightRect.height - rightBox.offsetHeight) / 2;
        const rightLeft = rightRect.right - containerRect.left + 12; // 12px gap
        rightBox.style.top = Math.max(4, rightTop) + 'px';
        rightBox.style.left = rightLeft + 'px';
    }

    // (resize handling consolidated into debounced onResize) // no-op

    // close on Escape
    document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape') { closeUserMenu(); closeDevMenu(); }
    });

    // utility to make an unordered pair key (same for [A,B] and [B,A])
    function pairKey(nameA, nameB) {
        return [nameA, nameB].sort().join('|||');
    }

    // Helper function to get the rank/position of a coaster by name
    function getCoasterRank(coasterName) {
        if (!coasterName || !coasterStats[coasterName]) return null;
        
        const statsArray = Object.values(coasterStats);
        const sorted = [...statsArray].sort((a, b) => b.rating - a.rating);
        
        return sorted.findIndex(c => c.name === coasterName) + 1;
    }

    // helper: record a battle into history
    function recordBattle(a, b, winnerName, loserName, { skipSave = false, battleStats = null } = {}) {
        const key = pairKey(a.naam, b.naam);
        const entry = {
            pairKey: key,
            left: a.naam,  // Store left position
            right: b.naam, // Store right position
            a: a.naam,
            b: b.naam,
            winner: winnerName,
            loser: loserName,
            timestamp: new Date().toISOString(),
            seed: (typeof seedNumber !== 'undefined') ? seedNumber : null
        };
        
        // Add comprehensive battle stats if provided
        if (battleStats) {
            entry.statsA = battleStats.statsA;
            entry.statsB = battleStats.statsB;
            entry.closeFight = battleStats.closeFight;
        }
        
        coasterHistory.push(entry);
        
        // Mark this pair as completed
        completedPairs.add(key);

        // keep history bounded (using predefined constant)
        if (coasterHistory.length > MAX_HISTORY_KEEP) coasterHistory.splice(0, coasterHistory.length - MAX_HISTORY_KEEP);

        if (!skipSave) saveData();
    }

    // Get total possible unique pairs
    function getTotalPossiblePairs() {
        const n = coasters.length;
        return (n * (n - 1)) / 2;
    }
    
    // Get remaining pairs count
    function getRemainingPairsCount() {
        return getTotalPossiblePairs() - completedPairs.size;
    }
    
    // Check if all pairs are completed
    function areAllPairsCompleted() {
        return getRemainingPairsCount() === 0;
    }

    // Pick a pair that hasn't been completed yet
    function getPairAvoidingDuplicates({ attempts = 200 } = {}) {
                const length = coasters.length;
                if (length < 2) return [];
                
                // Check if all pairs are completed
                if (areAllPairsCompleted()) {
                    return null; // Signal that no more pairs available
                }

                const randomFn = (typeof rng === 'function') ? rng : Math.random;

                // build base weights that give higher probability to coasters with fewer battles
                const weights = new Array(length);
                for (let i = 0; i < length; i++) {
                    try {
                        const name = coasters[i].naam;
                        const stats = coasterStats && coasterStats[name] ? coasterStats[name] : null;
                        const battles = stats && typeof stats.battles === 'number' ? stats.battles : 0;
                        // base exploration weight: inverse of (1 + battles) ^ EXPLORATION_POWER
                        let w = 1 / Math.pow(1 + Math.max(0, battles), EXPLORATION_POWER);
                        // No image bias - all coasters loaded before first battle
                        weights[i] = w;
                    } catch (e) {
                        weights[i] = 1;
                    }
                }

                // helper: sample an index from a weight array
                const sampleIndexFromWeights = (arr, rnd) => {
                    const tot = arr.reduce((s, v) => s + (isFinite(v) && v > 0 ? v : 0), 0);
                    if (!tot || !isFinite(tot) || tot <= 0) return Math.floor((rnd()) * length);
                    let r = rnd() * tot;
                    for (let k = 0; k < arr.length; k++) {
                        const val = isFinite(arr[k]) && arr[k] > 0 ? arr[k] : 0;
                        r -= val;
                        if (r <= 0) return k;
                    }
                    return arr.length - 1;
                };

                // Hybrid strategy: pick one under-sampled coaster first, then a second biased by rating-proximity
                // (still favors under-sampled ones via base weights)
                const indexFromExploration = () => sampleIndexFromWeights(weights, randomFn);
                for (let t = 0; t < attempts; t++) {
                    const i = indexFromExploration();
                    // use displayedRating (regularized) for pairing proximity calculations
                    const ratingI = (coasterStats && coasterStats[coasters[i].naam]) ? displayedRating(coasterStats[coasters[i].naam]) : GLICKO2_RATING_BASE;
                    const condWeights = new Array(length);
                    for (let k = 0; k < length; k++) {
                        if (k === i) { condWeights[k] = 0; continue; }
                        const nameK = coasters[k].naam;
                        const ratingK = (coasterStats && coasterStats[nameK]) ? displayedRating(coasterStats[nameK]) : GLICKO2_RATING_BASE;
                        const diff = Math.abs(ratingI - ratingK) / RATING_DIFF_SCALE; // normalized diff (using displayed rating)
                        const proximityFactor = 1 / Math.pow(1 + diff, RATING_PROXIMITY_POWER);
                        const base = isFinite(weights[k]) && weights[k] > 0 ? weights[k] : 1;
                        condWeights[k] = base * proximityFactor;
                    }

                    let j = sampleIndexFromWeights(condWeights, randomFn);
                    if (j === i) {
                        let guard = 0;
                        while (j === i && guard++ < 8) j = sampleIndexFromWeights(condWeights, randomFn);
                        if (j === i) j = (i + 1) % length;
                    }

                    const a = coasters[i], b = coasters[j];
                    const key = pairKey(a.naam, b.naam);
                    if (!completedPairs.has(key)) return [a, b];
                }

                // fallback scanning approach: try to find any unseen pair deterministically
                for (let i = 0; i < length; i++) {
                    for (let j = i + 1; j < length; j++) {
                        const a = coasters[i], b = coasters[j];
                        const key = pairKey(a.naam, b.naam);
                        if (!completedPairs.has(key)) {
                            if (randomFn() < 0.5) return [a, b]; else return [b, a];
                        }
                    }
                }

                // No more pairs available
                return null;
            }

    // Replace getRandomCoasters() with duplicate-avoiding wrapper
    function getRandomCoasters() {
        return getPairAvoidingDuplicates();
    }

    // ========================================
    // GLICKO-2 RATING SYSTEM IMPLEMENTATION
    // ========================================

    // Convert rating to Glicko-2 scale (Œº)
    function glicko2Scale(rating) {
        return (rating - GLICKO2_RATING_BASE) / GLICKO2_SCALE_FACTOR;
    }

    // Convert Glicko-2 scale back to rating
    function glicko2Unscale(mu) {
        return mu * GLICKO2_SCALE_FACTOR + GLICKO2_RATING_BASE;
    }

    // Convert RD to Glicko-2 scale (œÜ)
    function glicko2ScaleRD(rd) {
        return rd / GLICKO2_SCALE_FACTOR;
    }

    // Convert Glicko-2 scale back to RD
    function glicko2UnscaleRD(phi) {
        return phi * GLICKO2_SCALE_FACTOR;
    }

    // g(œÜ) function - measures impact of opponent's RD
    function glicko2_g(phi) {
        return 1 / Math.sqrt(1 + 3 * phi * phi / (Math.PI * Math.PI));
    }

    // E(Œº, Œº_j, œÜ_j) - expected score against opponent
    function glicko2_E(mu, mu_j, phi_j) {
        return 1 / (1 + Math.exp(-glicko2_g(phi_j) * (mu - mu_j)));
    }

    // Calculate new Glicko-2 ratings after a match
    // Returns: { newWinnerRating, newWinnerRD, newWinnerVolatility, newLoserRating, newLoserRD, newLoserVolatility }
    function calculateGlicko2(winnerStats, loserStats) {
        // Extract current values
        const r1 = winnerStats.rating || GLICKO2_RATING_BASE;
        const rd1 = winnerStats.rd || GLICKO2_RD_INITIAL;
        const vol1 = winnerStats.volatility || GLICKO2_VOLATILITY_INITIAL;
        
        const r2 = loserStats.rating || GLICKO2_RATING_BASE;
        const rd2 = loserStats.rd || GLICKO2_RD_INITIAL;
        const vol2 = loserStats.volatility || GLICKO2_VOLATILITY_INITIAL;

        // Convert to Glicko-2 scale
        const mu1 = glicko2Scale(r1);
        const phi1 = glicko2ScaleRD(rd1);
        const mu2 = glicko2Scale(r2);
        const phi2 = glicko2ScaleRD(rd2);

        // Calculate winner's new rating (won against loser)
        const result1 = calculateGlicko2Single(mu1, phi1, vol1, [{ mu: mu2, phi: phi2, score: 1 }]);
        
        // Calculate loser's new rating (lost against winner)
        const result2 = calculateGlicko2Single(mu2, phi2, vol2, [{ mu: mu1, phi: phi1, score: 0 }]);

        return {
            newWinnerRating: glicko2Unscale(result1.mu),
            newWinnerRD: glicko2UnscaleRD(result1.phi),
            newWinnerVolatility: result1.sigma,
            newLoserRating: glicko2Unscale(result2.mu),
            newLoserRD: glicko2UnscaleRD(result2.phi),
            newLoserVolatility: result2.sigma
        };
    }

    // Core Glicko-2 calculation for a single player against opponents
    function calculateGlicko2Single(mu, phi, sigma, opponents) {
        // Step 1: Calculate v (estimated variance)
        let v = 0;
        for (const opp of opponents) {
            const g_phi_j = glicko2_g(opp.phi);
            const E_val = glicko2_E(mu, opp.mu, opp.phi);
            v += g_phi_j * g_phi_j * E_val * (1 - E_val);
        }
        v = 1 / v;

        // Step 2: Calculate Œî (estimated improvement in rating)
        let delta = 0;
        for (const opp of opponents) {
            const g_phi_j = glicko2_g(opp.phi);
            const E_val = glicko2_E(mu, opp.mu, opp.phi);
            delta += g_phi_j * (opp.score - E_val);
        }
        delta *= v;

        // Step 3: Determine new volatility (œÉ')
        const sigma_new = calculateVolatility(sigma, phi, v, delta, GLICKO2_TAU);

        // Step 4: Update rating deviation to new pre-rating period value
        const phi_star = Math.sqrt(phi * phi + sigma_new * sigma_new);

        // Step 5: Update rating and RD
        const phi_new = 1 / Math.sqrt(1 / (phi_star * phi_star) + 1 / v);
        
        let mu_new = mu;
        for (const opp of opponents) {
            const g_phi_j = glicko2_g(opp.phi);
            const E_val = glicko2_E(mu, opp.mu, opp.phi);
            mu_new += phi_new * phi_new * g_phi_j * (opp.score - E_val);
        }

        return {
            mu: mu_new,
            phi: phi_new,
            sigma: sigma_new
        };
    }

    // Illinois algorithm to determine new volatility
    function calculateVolatility(sigma, phi, v, delta, tau) {
        const a = Math.log(sigma * sigma);
        const delta_sq = delta * delta;
        const phi_sq = phi * phi;
        
        // Define f(x)
        const f = (x) => {
            const ex = Math.exp(x);
            const phi_sq_ex = phi_sq + v + ex;
            const term1 = ex * (delta_sq - phi_sq - v - ex) / (2 * phi_sq_ex * phi_sq_ex);
            const term2 = (x - a) / (tau * tau);
            return term1 - term2;
        };

        // Initial values
        let A = a;
        let B;
        
        if (delta_sq > phi_sq + v) {
            B = Math.log(delta_sq - phi_sq - v);
        } else {
            let k = 1;
            while (f(a - k * tau) < 0) {
                k++;
            }
            B = a - k * tau;
        }

        let fA = f(A);
        let fB = f(B);

        // Iterate using Illinois algorithm
        while (Math.abs(B - A) > GLICKO2_EPSILON) {
            const C = A + (A - B) * fA / (fB - fA);
            const fC = f(C);

            if (fC * fB < 0) {
                A = B;
                fA = fB;
            } else {
                fA = fA / 2;
            }

            B = C;
            fB = fC;
        }

        return Math.exp(A / 2);
    }

    // Displayed rating with Bayesian-like shrinkage towards population mean (for ranking display)
    function displayedRating(stats) {
        if (!stats) return GLICKO2_RATING_BASE;
        const n = stats.battles || 0;
        if (n === 0) return GLICKO2_RATING_BASE;
        return (stats.rating * n + GLICKO2_RATING_BASE * PRIOR_WEIGHT) / (n + PRIOR_WEIGHT);
    }

    // ========================================
    // END GLICKO-2 RATING SYSTEM
    // ========================================

    // Ensure a coaster has an entry in `coasterStats`. Returns the stats object.
    function ensureCoasterStats(coaster) {
        if (!coaster || !coaster.naam) return null;
        const name = coaster.naam;
        if (!coasterStats[name]) {
            coasterStats[name] = {
                name: name,
                park: coaster.park || (coaster.park === undefined ? '' : coaster.park),
                manufacturer: coaster.fabrikant || coaster.manufacturer || '',
                rating: GLICKO2_RATING_BASE,
                rd: GLICKO2_RD_INITIAL,
                volatility: GLICKO2_VOLATILITY_INITIAL,
                battles: 0,
                wins: 0,
                losses: 0
            };
        }
        return coasterStats[name];
    }

    /* ===== Close-battle system =====
       - Rare epic overlay when two coasters are within 3 ranking spots
       - Only for coasters with more than 3 battles
       - Rare trigger once every 25-50 battles (per localStorage)
       - If adjacent and triggered, force a visible swap in ranking
    */
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    
    function initCloseBattleSystem(){
        if (localStorage.getItem(CR_STORAGE_COUNTER)===null) localStorage.setItem(CR_STORAGE_COUNTER,'0');
        if (localStorage.getItem(CR_STORAGE_THRESHOLD)===null) localStorage.setItem(CR_STORAGE_THRESHOLD,String(randInt(25,50)));
    }

    // Developer override: force the next matchup to be treated as a close battle (one-time)
    let devForceCloseBattle = false;

    // Find a random eligible close matchup (both >3 battles and rank difference <3)
    function findCloseMatchup() {
        const statsArray = Object.values(coasterStats || {});
        if (!statsArray || statsArray.length < 2) return null;
        // compute sorted ranks by displayedRating
        const sorted = [...statsArray].sort((a,b) => displayedRating(b) - displayedRating(a));
        const nameToRank = {};
        sorted.forEach((s, idx) => { nameToRank[s.name] = idx + 1; });

        // build eligible pairs
        const eligible = [];
        for (let i = 0; i < sorted.length; i++){
            for (let j = i+1; j < sorted.length; j++){
                const a = sorted[i], b = sorted[j];
                if ((a.battles||0) <= 3 || (b.battles||0) <= 3) continue;
                const diff = Math.abs(nameToRank[a.name] - nameToRank[b.name]);
                if (diff < 3) eligible.push([a, b]);
            }
        }
        if (eligible.length === 0) return null;
        const idx = Math.floor(Math.random() * eligible.length);
        // return original coaster objects from coasters array (to preserve .naam keys)
        const pick = eligible[idx];
        // try to map back to full coaster objects in `coasters`
        const aObj = coasters.find(c => (c.naam || c.name) === pick[0].name) || pick[0];
        const bObj = coasters.find(c => (c.naam || c.name) === pick[1].name) || pick[1];
        return [aObj, bObj];
    }

    // Dev action: set up a close fight for the next displayed battle
    function forceNextCloseFight(){
        if (!currentUser) { showToast('Select a user first'); return; }
        const pair = findCloseMatchup();
        if (!pair) { showToast('No suitable close matchup available'); return; }
        // set dev flag so triggerCloseBattleIfNeeded triggers the epic one-time
        devForceCloseBattle = true;
        // set currentBattle to the pair and re-render
        currentBattle = pair;
        displayBattle();
        showToast('Close fight forced ‚Äî choose winner');
    }

    function subtleCloseFlourish(a,b,winnerId){
        return new Promise((res)=>{
            try{
                const overlay = document.getElementById('closeBattleOverlay');
                const leftName = document.getElementById('cLeftName');
                const rightName = document.getElementById('cRightName');
                leftName.textContent = getCoasterName(a);
                rightName.textContent = getCoasterName(b);
                overlay.classList.add('show');
                // stronger celebratory burst for close fights (longer)
                const winnerBurst = document.getElementById('winnerBurst');
                winnerBurst.classList.add('show');
                // add slight scale/pop on winner text for effect
                const winnerText = document.getElementById('winnerText');
                winnerText.style.transform = 'scale(0.95)';
                setTimeout(()=>{ winnerText.style.transform = 'scale(1.12)'; }, 80);
                setTimeout(()=>{ winnerText.style.transform = ''; winnerBurst.classList.remove('show'); overlay.classList.remove('show'); res(); }, 1200);
            }catch(e){ res(); }
        });
    }

    function epicCloseBattleSequence(a,b, rankA, rankB, winnerId){
        return new Promise((resolve)=>{
            const overlay = document.getElementById('closeBattleOverlay');
            const leftName = document.getElementById('cLeftName');
            const rightName = document.getElementById('cRightName');
            const cLeft = document.getElementById('cLeft');
            const cRight = document.getElementById('cRight');
            const winnerBurst = document.getElementById('winnerBurst');
            const winnerText = document.getElementById('winnerText');

            leftName.textContent = getCoasterName(a);
            rightName.textContent = getCoasterName(b);
            overlay.classList.add('show');

            cLeft.classList.remove('win','lose');
            cRight.classList.remove('win','lose');
            winnerBurst.classList.remove('show');

            setTimeout(()=>{
                const leftIsWinner = (winnerId === getCoasterId(a));
                if (leftIsWinner){ cLeft.classList.add('win'); cRight.classList.add('lose'); winnerText.textContent = `${getCoasterName(a)} wins!`; }
                else { cRight.classList.add('win'); cLeft.classList.add('lose'); winnerText.textContent = `${getCoasterName(b)} wins!`; }
                winnerBurst.classList.add('show');

                const CELEBRATE_MS = 1600;
                setTimeout(()=>{
                    winnerBurst.classList.remove('show');
                    overlay.classList.remove('show');
                    const diff = Math.abs(rankA - rankB);
                    const forcedSwap = diff === 1; // adjacent -> force swap
                    resolve(forcedSwap);
                }, CELEBRATE_MS);
            }, 420);
        });
    }

    // Show an intro animation/banner when a close fight appears
    function showCloseIntro(a,b){
        return new Promise((resolve)=>{
            try{
                // mark intro active so other flows don't re-trigger it
                closeIntroActive = true;
                // temporarily block choices to ensure user notices
                const prevProcessing = isProcessingChoice;
                isProcessingChoice = true;

                const overlay = document.getElementById('closeBattleOverlay');
                const banner = document.getElementById('closeBanner');
                const cards = document.querySelectorAll('.coaster-card');
                const battleContainerEl = DOM.battleContainer || document.getElementById('battleContainer');
                // bring cards above overlay during intro
                const prevZ = battleContainerEl && battleContainerEl.style ? battleContainerEl.style.zIndex : null;
                if (battleContainerEl) battleContainerEl.style.zIndex = 10030;
                // ensure any forced inline hiding is removed so the overlay can appear
                try {
                    if (overlay) {
                        overlay.style.removeProperty('display');
                        overlay.style.removeProperty('opacity');
                        overlay.style.removeProperty('z-index');
                        overlay.removeAttribute('aria-hidden');
                    }
                    if (banner) {
                        banner.style.removeProperty('display');
                        banner.removeAttribute('aria-hidden');
                    }
                } catch (e) {}
                // set overlay to a visible intro state
                overlay.classList.add('show');
                banner.classList.add('show');
                // highlight the two cards
                if (cards[0]) { cards[0].classList.add('close-highlight'); cards[0].classList.add('close-hidden'); }
                if (cards[1]) { cards[1].classList.add('close-highlight'); cards[1].classList.add('close-hidden'); }

                // small attention animation on VS marker; hide the original VS while overlay shows its own
                const vs = document.querySelector('.vs-divider');
                try{
                    if (vs) {
                        closeIntroPrevVSDisplay = (vs.style && vs.style.display) ? vs.style.display : '';
                        vs.style.setProperty('display','none','important');
                        vs.setAttribute('data-cr-hidden','true');
                        vs.animate([
                            { transform: 'scale(1)', offset: 0 },
                            { transform: 'scale(1.12)', offset: 0.5 },
                            { transform: 'scale(1)', offset: 1 }
                        ], { duration: 700, easing: 'cubic-bezier(.2,.9,.3,1)' });
                    }
                }catch(e){}

                // play intro for a bit longer, then reveal cards one by one
                const BANNER_MS = 2200; // slower intro
                setTimeout(()=>{
                    // reveal left then right with a small stagger
                    if (cards[0]) {
                        cards[0].classList.remove('close-hidden');
                        cards[0].classList.add('revealed');
                        cards[0].classList.add('pop');
                        setTimeout(()=>{ cards[0].classList.remove('pop'); }, 700);
                    }
                    setTimeout(()=>{
                        if (cards[1]) { cards[1].classList.remove('close-hidden'); cards[1].classList.add('revealed'); cards[1].classList.add('pop'); setTimeout(()=>{ cards[1].classList.remove('pop'); }, 700); }
                        // hide banner and overlay after a short pause so cards are visible
                        setTimeout(()=>{
                            banner.classList.remove('show');
                                overlay.classList.remove('show');
                                if (cards[0]) cards[0].classList.remove('close-highlight');
                                if (cards[1]) cards[1].classList.remove('close-highlight');
                                // restore battle container z-index
                                if (battleContainerEl) battleContainerEl.style.zIndex = prevZ || '';
                                isProcessingChoice = prevProcessing;
                                // mark intro finished
                                closeIntroActive = false;
                                // restore original VS marker display if we saved it
                                try {
                                    if (vs) {
                                        if (closeIntroPrevVSDisplay !== null && closeIntroPrevVSDisplay !== '') vs.style.display = closeIntroPrevVSDisplay; else vs.style.removeProperty('display');
                                        vs.removeAttribute('data-cr-hidden');
                                        closeIntroPrevVSDisplay = null;
                                    }
                                } catch(e) {}
                                resolve();
                        }, 800);
                    }, 520);
                }, BANNER_MS);
            }catch(e){ isProcessingChoice = false; resolve(); }
        });
    }

    // Celebrate a winner by animating the existing card in-place and spawning confetti
    function celebrateWinner(cardEl, winnerName){
        return new Promise((resolve)=>{
            try {
                if (!cardEl) return resolve();

                const overlayEl = document.getElementById('closeBattleOverlay');
                const bannerEl = document.getElementById('closeBanner');
                const winnerBurst = document.getElementById('winnerBurst');
                const prev = {};
                
                if (overlayEl) {
                    prev.overlayDisplay = overlayEl.style.display;
                    prev.overlayOpacity = overlayEl.style.opacity;
                    prev.overlayZ = overlayEl.style.zIndex;
                    overlayEl.classList.remove('show');
                    overlayEl.style.setProperty('display', 'none', 'important');
                    overlayEl.style.setProperty('opacity', '0', 'important');
                    overlayEl.style.zIndex = '';
                    overlayEl.setAttribute('aria-hidden', 'true');
                }
                if (bannerEl) bannerEl.classList.remove('show');
                if (winnerBurst) winnerBurst.classList.remove('show','big');
                cardEl._closeOverlayPrev = prev;

                cardEl.classList.add('celebrate-in-place');

                const rect = cardEl.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 3;

                const colors = ['#ff3f6e','#ffd86b','#6ee7b7','#7dd3fc','#c084fc','#ffc4d6','#ffb86b'];
                const confettiCount = 36;
                const confettiEls = [];
                
                for (let i = 0; i < confettiCount; i++){
                    const c = document.createElement('div');
                    c.className = 'confetti-piece';
                    const size = 6 + Math.floor(Math.random()*12);
                    c.style.width = size + 'px';
                    c.style.height = Math.floor(size*1.2) + 'px';
                    c.style.left = (cx + (Math.random()*rect.width - rect.width/2)) + 'px';
                    c.style.top = (cy + (Math.random()*rect.height/2 - rect.height/4)) + 'px';
                    c.style.background = colors[Math.floor(Math.random()*colors.length)];
                    c.style.transform = `translateY(-6px) rotate(${Math.random()*360}deg)`;
                    c.style.animationDuration = (900 + Math.floor(Math.random()*900)) + 'ms';
                    document.body.appendChild(c);
                    confettiEls.push(c);
                }

                const winnerText = document.getElementById('winnerText');
                if (winnerText) winnerText.textContent = `${winnerName} WINS!`;
                if (winnerBurst) winnerBurst.classList.add('show','big');

                setTimeout(()=>{
                    try{
                        if (winnerBurst) winnerBurst.classList.remove('show','big');
                        confettiEls.forEach(c => c.remove());
                        cardEl.classList.remove('celebrate-in-place');
                        
                        const prev = cardEl._closeOverlayPrev;
                        const overlayEl = document.getElementById('closeBattleOverlay');
                        if (prev && overlayEl) {
                            if (prev.overlayDisplay) overlayEl.style.display = prev.overlayDisplay; 
                            else overlayEl.style.removeProperty('display');
                            if (prev.overlayOpacity) overlayEl.style.opacity = prev.overlayOpacity; 
                            else overlayEl.style.removeProperty('opacity');
                            if (prev.overlayZ) overlayEl.style.zIndex = prev.overlayZ; 
                            else overlayEl.style.removeProperty('z-index');
                            overlayEl.removeAttribute('aria-hidden');
                            delete cardEl._closeOverlayPrev;
                        }
                        try { restoreVsDivider(); } catch(e) {}
                    }catch(e){}
                    resolve();
                }, 1400);
            } catch(e) { 
                resolve(); 
            }
        });
    }

    function triggerCloseBattleIfNeeded(coasterA, coasterB, rankA, rankB, winnerId){
        return new Promise((resolve)=>{
            // require >3 battles each
            const aStats = coasterStats[(coasterA.naam || coasterA.name)];
            const bStats = coasterStats[(coasterB.naam || coasterB.name)];
            if (!aStats || !bStats) return resolve({triggered:false, forcedSwap:false});
            if ((aStats.battles||0) <= 3 || (bStats.battles||0) <= 3) return resolve({triggered:false, forcedSwap:false});

            const diff = Math.abs(rankA - rankB);
            if (!(diff < 3)) return resolve({triggered:false, forcedSwap:false});

            // If we're currently resolving a winner choice, don't trigger the intro
            if (resolvingBattle) {
                // ensure any visible overlay is hidden and don't trigger epic
                try { cancelCloseIntro(); } catch(e){}
                return resolve({triggered:false, forcedSwap:false});
            }

            // dev override: if developer forced a close battle, trigger epic once
            if (typeof devForceCloseBattle !== 'undefined' && devForceCloseBattle) {
                devForceCloseBattle = false; // one-time
                // reset stored counters so rarity doesn't immediately retrigger
                localStorage.setItem(CR_STORAGE_COUNTER,'0');
                localStorage.setItem(CR_STORAGE_THRESHOLD,String(randInt(25,50)));
                epicCloseBattleSequence(coasterA, coasterB, rankA, rankB, winnerId).then((forcedSwap)=>{
                    resolve({triggered:true, forcedSwap: !!forcedSwap});
                });
                return;
            }

            // If the intro is already active or the overlay is visible, treat the epic as already shown
            try {
                const overlayCheck = document.getElementById('closeBattleOverlay');
                if (closeIntroActive || (overlayCheck && overlayCheck.classList.contains('show'))) {
                    // reset counter/threshold as if epic triggered
                    localStorage.setItem(CR_STORAGE_COUNTER,'0');
                    localStorage.setItem(CR_STORAGE_THRESHOLD,String(randInt(25,50)));
                    const forcedSwap = diff === 1;
                    return resolve({triggered:true, forcedSwap: !!forcedSwap});
                }
            } catch (e) { /* ignore */ }

            let counter = Number(localStorage.getItem(CR_STORAGE_COUNTER) || 0);
            let threshold = Number(localStorage.getItem(CR_STORAGE_THRESHOLD) || randInt(25,50));
            counter++;
            localStorage.setItem(CR_STORAGE_COUNTER, String(counter));

            const shouldTrigger = counter >= threshold;
            if (!shouldTrigger){
                return subtleCloseFlourish(coasterA, coasterB, winnerId).then(()=> resolve({triggered:false, forcedSwap:false}));
            }

            // reset counter and set new threshold
            localStorage.setItem(CR_STORAGE_COUNTER,'0');
            localStorage.setItem(CR_STORAGE_THRESHOLD,String(randInt(25,50)));

            // Show the intro overlay first, then the epic sequence
            showCloseIntro(coasterA, coasterB).then(() => {
                epicCloseBattleSequence(coasterA, coasterB, rankA, rankB, winnerId).then((forcedSwap)=>{
                    resolve({triggered:true, forcedSwap: !!forcedSwap});
                });
            }).catch(() => {
                // If intro fails, still show epic sequence
                epicCloseBattleSequence(coasterA, coasterB, rankA, rankB, winnerId).then((forcedSwap)=>{
                    resolve({triggered:true, forcedSwap: !!forcedSwap});
                });
            });
        });
    }

    function animateSwapInRanking(idA, idB){
        try{
            const rowA = document.querySelector(`#rankingBody tr[data-id="${idA}"]`);
            const rowB = document.querySelector(`#rankingBody tr[data-id="${idB}"]`);
            if (!rowA || !rowB) return;
            rowA.classList.add('cr-swap-animate'); rowB.classList.add('cr-swap-animate');
            setTimeout(()=>{ rowA.classList.remove('cr-swap-animate'); rowB.classList.remove('cr-swap-animate'); }, 900);
            const parent = rowA.parentNode;
            if (parent && rowA && rowB){
                const next = rowA.nextElementSibling === rowB ? rowB.nextElementSibling : rowA.nextElementSibling;
                parent.insertBefore(rowB, rowA);
                if (next) parent.insertBefore(rowA, next);
            }
        }catch(e){ console.warn('animateSwapInRanking failed',e); }
    }

    // initialize storage counters
    initCloseBattleSystem();

    async function displayBattle() {
        // Reset resolving state and hide any overlays from previous battles
        resolvingBattle = false;
        try {
            cancelCloseIntro();
            const overlay = document.getElementById('closeBattleOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                overlay.style.display = 'none';
            }
        } catch (e) { /* ignore */ }
        
        const battleContainerEl = DOM.battleContainer;
        // If no user selected, show hint
        if (!currentUser) {
            (DOM.battleContainer || $id('battleContainer')).innerHTML = '<div class="no-battles">Select a user above first! üëÜ</div>';
            try { if (battleContainerEl) battleContainerEl.style.display = 'none'; } catch (e) {}
            currentBattle = null;
            return;
        }

        // if there aren't enough active coasters, show a helpful message
        if (!coasters || coasters.length < 2) {
            (DOM.battleContainer || $id('battleContainer')).innerHTML = '<div class="no-battles">No active coasters found for this user. Check your CSV or the "operational" column.</div>';
            currentBattle = null;
            return;
        }

        // If developer forced a close battle and `currentBattle` is already set, don't overwrite it.
        // Also check if we have a saved battle from previous session/tab switch
        if (!currentBattle || (!devForceCloseBattle && currentBattle.length !== 2)) {
            currentBattle = getRandomCoasters();
        }
        const battleContainer = DOM.battleContainer || $id('battleContainer');
        
        // Save the battle for persistence
        saveData();
        
        // Check if no more pairs available
        if (!currentBattle || currentBattle.length === 0) {
            battleContainer.innerHTML = '<div class="no-battles">üéâ Congratulations!<br><br>You have completed all possible matchups!<br><br>Check the ranking tab to see your final list.</div>';
            return;
        }

        try { if (battleContainerEl) battleContainerEl.style.display = ''; } catch (e) {}
        
        // Get current rankings for both coasters (cache sorted array)
        const statsArray = Object.values(coasterStats);
        const sortedByRating = [...statsArray].sort((a, b) => b.rating - a.rating);
    function getRanking(coasterName) {
        if (!sortedByRating) {
            const statsArray = Object.values(coasterStats);
            sortedByRating = [...statsArray].sort((a, b) => b.rating - a.rating);
        }
        return sortedByRating.findIndex(c => c.name === coasterName) + 1;
    }
        
        const rank1 = getRanking(currentBattle[0].naam);
        const rank2 = getRanking(currentBattle[1].naam);
        
        // dev data calculations
        const left = currentBattle[0], right = currentBattle[1];
        const leftStats = coasterStats[left.naam] || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };
        const rightStats = coasterStats[right.naam] || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };
        // compute Glicko-2 scenarios once
        const leftIfWin = calculateGlicko2(leftStats, rightStats);
        const leftIfLose = calculateGlicko2(rightStats, leftStats);
        const leftGainWin = Math.round(leftIfWin.newWinnerRating - leftStats.rating);
        const leftLoseIfLose = Math.round(leftIfLose.newLoserRating - leftStats.rating);
        const rightGainWin = Math.round(leftIfLose.newWinnerRating - rightStats.rating);
        const rightLoseIfLose = Math.round(leftIfWin.newLoserRating - rightStats.rating);
        const fmt = (n) => (n >= 0 ? '+' + n : n.toString());
        
        const devLeftHtml = `
            <div><strong>Rank:</strong> ${rank1}</div>
            <div><strong>Rating:</strong> ${Math.round(leftStats.rating)} ¬± ${Math.round(leftStats.rd)}</div>
            <div><strong>Œî (win):</strong> ${fmt(leftGainWin)}</div>
            <div><strong>Œî (lose):</strong> ${fmt(leftLoseIfLose)}</div>
            <div><strong>Battles:</strong> ${leftStats.battles}</div>
            <div><strong>Wins:</strong> ${leftStats.wins}</div>
            <div><strong>Losses:</strong> ${leftStats.losses}</div>
        `;
        const devRightHtml = `
            <div><strong>Rank:</strong> ${rank2}</div>
            <div><strong>Rating:</strong> ${Math.round(rightStats.rating)} ¬± ${Math.round(rightStats.rd)}</div>
            <div><strong>Œî (win):</strong> ${fmt(rightGainWin)}</div>
            <div><strong>Œî (lose):</strong> ${fmt(rightLoseIfLose)}</div>
            <div><strong>Battles:</strong> ${rightStats.battles}</div>
            <div><strong>Wins:</strong> ${rightStats.wins}</div>
            <div><strong>Losses:</strong> ${rightStats.losses}</div>
        `;
        
        // Check for matching park or manufacturer
        const matchingPark = left.park && right.park && left.park.toLowerCase() === right.park.toLowerCase();
        const matchingFabrikant = left.fabrikant && right.fabrikant && left.fabrikant.toLowerCase() === right.fabrikant.toLowerCase();
        const parkClass = matchingPark ? 'match-highlight' : '';
        const fabrikantClass = matchingFabrikant ? 'match-highlight' : '';
        
        // Load images first and wait for them to be ready
        const leftImageUrl = getCoasterImageSync(left);
        const rightImageUrl = getCoasterImageSync(right);
        
        // Preload both images to ensure they're ready before rendering
        await Promise.all([
            preloadImage(leftImageUrl),
            preloadImage(rightImageUrl)
        ]);
        
        // Start background preloading for next battles
        setTimeout(() => preloadNextBattles(), 50);
        
        // Check if this is a close fight (will be used for banner)
        const leftStatsForCheck = coasterStats[left.naam] || { battles: 0 };
        const rightStatsForCheck = coasterStats[right.naam] || { battles: 0 };
        const isCloseFightMatch = ((Math.abs(rank1 - rank2) <= 3) && (leftStatsForCheck.battles >= 3) && (rightStatsForCheck.battles >= 3));
        
        // Render cards with images already loaded
        battleContainer.innerHTML = `
            ${isCloseFightMatch ? '<div class="close-fight-banner">‚öîÔ∏è CLOSE FIGHT ‚öîÔ∏è</div>' : ''}
            <div class="coaster-item">
                <div class="coaster-card left-card" data-choice="0">
                    <div class="coaster-image">
                        <img class="coaster-img" src="${leftImageUrl}" alt="${escapeHtml(left.naam)}" />
                    </div>
                    <div class="coaster-rank-badge">${rank1}</div>
                    <div class="coaster-content">
                        <div class="coaster-name">${left.naam}</div>
                        <div class="coaster-subtitle">
                            <span class="${parkClass}">${left.park}</span>
                            <span class="separator">‚Ä¢</span>
                            <span class="${fabrikantClass}">${left.fabrikant}</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="coaster-item">
                <div class="coaster-card right-card" data-choice="1">
                    <div class="coaster-image">
                        <img class="coaster-img" src="${rightImageUrl}" alt="${escapeHtml(right.naam)}" />
                    </div>
                    <div class="coaster-rank-badge">${rank2}</div>
                    <div class="coaster-content">
                        <div class="coaster-name">${right.naam}</div>
                        <div class="coaster-subtitle">
                            <span class="${parkClass}">${right.park}</span>
                            <span class="separator">‚Ä¢</span>
                            <span class="${fabrikantClass}">${right.fabrikant}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add click handlers AFTER rendering (gives better control over event propagation)
        const coasterCards = battleContainer.querySelectorAll('.coaster-card');
        coasterCards.forEach(card => {
            card.addEventListener('click', (e) => {
                // STRICT CHECK: Do NOT trigger if clicking inside dev-data overlay
                const clickedOverlay = e.target.classList.contains('dev-data-overlay') || e.target.closest('.dev-data-overlay');
                if (clickedOverlay) {
                    return; // Do nothing
                }
                
                const choice = parseInt(card.getAttribute('data-choice'));
                chooseWinner(choice);
            });
        });

        // If this matchup qualifies as a close fight, play the intro animation
        const getRankingNum = (coasterName) => {
            const statsArray = Object.values(coasterStats);
            const sorted = [...statsArray].sort((a, b) => b.rating - a.rating);
            return sorted.findIndex(c => c.name === coasterName) + 1;
        };
        const r1 = getRankingNum(left.naam);
        const r2 = getRankingNum(right.naam);
        const leftStatsObj = coasterStats[left.naam] || { battles: 0 };
        const rightStatsObj = coasterStats[right.naam] || { battles: 0 };
        const isCloseEligible = ((Math.abs(r1 - r2) <= 3) && (leftStatsObj.battles >= 3) && (rightStatsObj.battles >= 3));
        // Determine whether an epic intro will fire on the next battle (rare event)
        function willEpicTriggerOnNext(){
            try{
                const counter = Number(localStorage.getItem(CR_STORAGE_COUNTER) || 0);
                const threshold = Number(localStorage.getItem(CR_STORAGE_THRESHOLD) || randInt(25,50));
                return (counter + 1) >= threshold;
            }catch(e){ return false; }
        }

        // If dev forced a close battle, show intro immediately (before cards are visible)
        if (devForceCloseBattle) {
            try { if (closeIntroTimeout) { clearTimeout(closeIntroTimeout); closeIntroTimeout = null; } } catch (e) {}
            // Trigger intro immediately with no delay
            showCloseIntro(left, right).catch(()=>{});
        } else if (isCloseEligible) {
            // Always show the full intro sequence for close fights
            try { if (closeIntroTimeout) { clearTimeout(closeIntroTimeout); closeIntroTimeout = null; } } catch (e) {}
            closeIntroTimeout = setTimeout(() => { closeIntroTimeout = null; showCloseIntro(left, right).catch(()=>{}); }, 60);
        }

        // Delegate overlay rendering to a dedicated function so we can update without reselecting the pair
        renderDevData();
        // sync input width after cards are rendered
        setTimeout(syncSimInputWidth, 0);
    }

    // Explicitly hide/show the battle UI (cards). Use this from tab switching
    function setBattleVisibility(visible) {
        const battleContainerEl = DOM.battleContainer;
        try {
            if (battleContainerEl) battleContainerEl.style.display = visible ? '' : 'none';
        } catch (e) {}
    }

    function chooseWinner(index) {
        if (!currentUser) return;
        if (isProcessingChoice) return; // Prevent double-clicking
        isProcessingChoice = true;

        // Mark we're resolving so intros won't re-run and cancel any pending/active intro immediately
        resolvingBattle = true;
        try { cancelCloseIntro(); } catch (e) { /* ignore */ }

        const winner = currentBattle[index];
        const loser = currentBattle[1 - index];

        // ranking helper (cache sorted array for efficiency)
        const statsArray = Object.values(coasterStats);
        const sortedStats = [...statsArray].sort((a, b) => b.rating - a.rating);
        const getRanking = (coasterName) => {
            return sortedStats.findIndex(c => c.name === coasterName) + 1;
        };

        const oldWinnerRank = getRanking(winner.naam);
        const oldLoserRank = getRanking(loser.naam);

        // ensure stats exist
        const winnerStats = ensureCoasterStats(winner) || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };
        const loserStats = ensureCoasterStats(loser) || { rating:GLICKO2_RATING_BASE, rd:GLICKO2_RD_INITIAL, volatility:GLICKO2_VOLATILITY_INITIAL, battles:0, wins:0, losses:0 };

        // Capture rating values BEFORE battle
        const winnerRatingBefore = winnerStats.rating;
        const loserRatingBefore = loserStats.rating;
        const winnerRDBefore = winnerStats.rd;
        const loserRDBefore = loserStats.rd;
        const winnerVolatilityBefore = winnerStats.volatility;
        const loserVolatilityBefore = loserStats.volatility;

        // compute Glicko-2 outcome
        const glickoOutcome = calculateGlicko2(winnerStats, loserStats);
        const { newWinnerRating, newWinnerRD, newWinnerVolatility, newLoserRating, newLoserRD, newLoserVolatility } = glickoOutcome;
        
        // Calculate expected win probabilities (using Glicko-2 scale)
        const mu1 = glicko2Scale(winnerRatingBefore);
        const phi1 = glicko2ScaleRD(winnerRDBefore);
        const mu2 = glicko2Scale(loserRatingBefore);
        const phi2 = glicko2ScaleRD(loserRDBefore);
        const expectedWinnerProb = glicko2_E(mu1, mu2, phi2);
        const expectedLoserProb = 1 - expectedWinnerProb;
        
        // Calculate potential gains/losses for both outcomes
        const winnerPotentialGain = newWinnerRating - winnerRatingBefore;
        const loserPotentialLoss = newLoserRating - loserRatingBefore;
        
        // Calculate what would happen if loser won instead
        const loserIfWinOutcome = calculateGlicko2(loserStats, winnerStats);
        const loserPotentialGain = loserIfWinOutcome.newWinnerRating - loserRatingBefore;
        const winnerPotentialLoss = loserIfWinOutcome.newLoserRating - winnerRatingBefore;

        const winnerId = getCoasterId(winner);

        // trigger close-battle flow (may show overlay). Wait for it before applying model updates so animation aligns with visible change
        triggerCloseBattleIfNeeded(winner, loser, oldWinnerRank, oldLoserRank, winnerId).then(({triggered, forcedSwap}) => {
            // apply ranking changes
            if (forcedSwap) {
                // Check if normal Glicko-2 calculation would already cause a position swap
                if (newWinnerRating > newLoserRating) {
                    // Normal calculation already results in winner being above loser - use it to maintain consistency
                    winnerStats.rating = newWinnerRating;
                    winnerStats.rd = newWinnerRD;
                    winnerStats.volatility = newWinnerVolatility;
                    loserStats.rating = newLoserRating;
                    loserStats.rd = newLoserRD;
                    loserStats.volatility = newLoserVolatility;
                } else {
                    // Force winner to be above loser (only when necessary)
                    const baseLoserRating = (loserStats && typeof loserStats.rating === 'number') ? loserStats.rating : GLICKO2_RATING_BASE;
                    winnerStats.rating = baseLoserRating + 2;
                    winnerStats.rd = newWinnerRD;
                    winnerStats.volatility = newWinnerVolatility;
                    loserStats.rating = baseLoserRating - 1;
                    loserStats.rd = newLoserRD;
                    loserStats.volatility = newLoserVolatility;
                }
            } else {
                winnerStats.rating = newWinnerRating;
                winnerStats.rd = newWinnerRD;
                winnerStats.volatility = newWinnerVolatility;
                loserStats.rating = newLoserRating;
                loserStats.rd = newLoserRD;
                loserStats.volatility = newLoserVolatility;
            }

            winnerStats.battles++; winnerStats.wins++;
            loserStats.battles++; loserStats.losses++;
            totalBattlesCount++;

            // Get ranks after rating changes
            const newWinnerRank = getCoasterRank(winner.naam);
            const newLoserRank = getCoasterRank(loser.naam);
            
            // Determine if this was a close fight
            const wasCloseMatchFlag = Math.abs(oldWinnerRank - oldLoserRank) < 3;
            
            // Build comprehensive battle stats for storage
            const battleStats = {
                statsA: {
                    ratingBefore: (currentBattle[0].naam === winner.naam) ? winnerRatingBefore : loserRatingBefore,
                    ratingAfter: (currentBattle[0].naam === winner.naam) ? winnerStats.rating : loserStats.rating,
                    rdBefore: (currentBattle[0].naam === winner.naam) ? winnerRDBefore : loserRDBefore,
                    rdAfter: (currentBattle[0].naam === winner.naam) ? winnerStats.rd : loserStats.rd,
                    volatilityBefore: (currentBattle[0].naam === winner.naam) ? winnerVolatilityBefore : loserVolatilityBefore,
                    volatilityAfter: (currentBattle[0].naam === winner.naam) ? winnerStats.volatility : loserStats.volatility,
                    potentialGain: (currentBattle[0].naam === winner.naam) ? winnerPotentialGain : loserPotentialGain,
                    potentialLoss: (currentBattle[0].naam === winner.naam) ? winnerPotentialLoss : loserPotentialLoss,
                    rankBefore: (currentBattle[0].naam === winner.naam) ? oldWinnerRank : oldLoserRank,
                    rankAfter: (currentBattle[0].naam === winner.naam) ? newWinnerRank : newLoserRank,
                    expectedWinProbability: (currentBattle[0].naam === winner.naam) ? expectedWinnerProb : expectedLoserProb,
                    totalBattlesBefore: (currentBattle[0].naam === winner.naam) ? winnerStats.battles - 1 : loserStats.battles - 1
                },
                statsB: {
                    ratingBefore: (currentBattle[1].naam === winner.naam) ? winnerRatingBefore : loserRatingBefore,
                    ratingAfter: (currentBattle[1].naam === winner.naam) ? winnerStats.rating : loserStats.rating,
                    rdBefore: (currentBattle[1].naam === winner.naam) ? winnerRDBefore : loserRDBefore,
                    rdAfter: (currentBattle[1].naam === winner.naam) ? winnerStats.rd : loserStats.rd,
                    volatilityBefore: (currentBattle[1].naam === winner.naam) ? winnerVolatilityBefore : loserVolatilityBefore,
                    volatilityAfter: (currentBattle[1].naam === winner.naam) ? winnerStats.volatility : loserStats.volatility,
                    potentialGain: (currentBattle[1].naam === winner.naam) ? winnerPotentialGain : loserPotentialGain,
                    potentialLoss: (currentBattle[1].naam === winner.naam) ? winnerPotentialLoss : loserPotentialLoss,
                    rankBefore: (currentBattle[1].naam === winner.naam) ? oldWinnerRank : oldLoserRank,
                    rankAfter: (currentBattle[1].naam === winner.naam) ? newWinnerRank : newLoserRank,
                    expectedWinProbability: (currentBattle[1].naam === winner.naam) ? expectedWinnerProb : expectedLoserProb,
                    totalBattlesBefore: (currentBattle[1].naam === winner.naam) ? winnerStats.battles - 1 : loserStats.battles - 1
                },
                closeFight: wasCloseMatchFlag
            };

            // record and persist with comprehensive stats
            recordBattle(currentBattle[0], currentBattle[1], winner.naam, loser.naam, { battleStats });
            saveData();

            // Update daily quest and session stats
            updateDailyQuest();
            updateSessionStats(wasCloseMatchFlag);

            // Track for achievements
            const wasCloseFight = Math.abs(oldWinnerRank - oldLoserRank) <= 3;
            const perfectMatch = (winner.park === loser.park) && 
                               (winner.fabrikant === loser.fabrikant) &&
                               winner.park && loser.park && 
                               winner.fabrikant && loser.fabrikant;
            // Check if underdog won (lower-ranked coaster won in a close fight)
            const underdogWon = wasCloseFight && (oldWinnerRank > oldLoserRank);
            
            if (typeof achievementManager !== 'undefined') {
                achievementManager.recordBattle(index, perfectMatch, wasCloseFight, currentBattle[0].naam, currentBattle[1].naam, underdogWon);
            }

            // Visual feedback on cards
            const cards = document.querySelectorAll('.coaster-card');
            if (cards[index]) cards[index].classList.add('winner');
            if (cards[1 - index]) cards[1 - index].classList.add('loser');

            // compute rank change (newWinnerRank already calculated above)
            const rankChange = oldWinnerRank - newWinnerRank; // positive = climbed

            if (rankChange > 0) {
                const badge = document.createElement('div');
                badge.className = 'rank-change-badge';
                badge.innerHTML = `<span class="arrow">‚Üë</span><span>+${rankChange}</span>`;
                if (cards[index]) { cards[index].style.position = 'relative'; cards[index].appendChild(badge); }
                setTimeout(() => { if (badge.parentElement) badge.remove(); }, 2000);
            }

            // refresh ranking table and animate swap if the relative ordering changed between these two
            updateRanking();
            // if winner and loser switched relative order compared to before, animate swap
            // (newWinnerRank and newLoserRank already calculated above)
            const wasWinnerBelow = oldWinnerRank > oldLoserRank;
            const nowWinnerAbove = newWinnerRank < newLoserRank;
            if (wasWinnerBelow && nowWinnerAbove) {
                animateSwapInRanking(winner.naam, loser.naam);
            }

            // after updating ranking, if this was a close matchup, show an extended celebration
            const wasCloseMatch = Math.abs(oldWinnerRank - oldLoserRank) < 3;
            if (wasCloseMatch) {
                // ensure any intro overlay/banner/burst is hidden before celebration (force-hide immediately)
                try {
                    const overlayEl = document.getElementById('closeBattleOverlay');
                    const bannerEl = document.getElementById('closeBanner');
                    const winnerBurstEl = document.getElementById('winnerBurst');
                    if (bannerEl) bannerEl.classList.remove('show');
                    if (winnerBurstEl) winnerBurstEl.classList.remove('show','big');
                    if (overlayEl) {
                        overlayEl.classList.remove('show');
                        // forcefully hide overlay (use !important so CSS transitions or async re-add don't briefly show it)
                        overlayEl.style.setProperty('display', 'none', 'important');
                        overlayEl.style.setProperty('opacity', '0', 'important');
                        overlayEl.style.zIndex = '';
                        overlayEl.setAttribute('aria-hidden', 'true');
                    }
                } catch (e) { /* ignore */ }

                const cardEl = (document.querySelectorAll('.coaster-card') || [])[index];
                celebrateWinner(cardEl, winner.naam).then(()=>{
                    // Check achievements after celebration
                    checkAndShowAchievements();
                    // Clear current battle before displaying next one
                    currentBattle = null;
                    // small pause then continue
                    setTimeout(()=>{ displayBattle(); isProcessingChoice = false; resolvingBattle = false; }, 150);
                });
            } else {
                // delay before next battle: celebrate longer if we triggered epic
                const DELAY = triggered ? 1000 : 800;
                // Clear current battle before displaying next one
                currentBattle = null;
                setTimeout(()=>{ 
                    displayBattle(); 
                    isProcessingChoice = false; 
                    resolvingBattle = false;
                    // Check achievements after battle completes
                    checkAndShowAchievements();
                }, DELAY);
            }
        }).catch((e)=>{
            console.error('close-battle flow error', e);
            // fallback apply normally (without comprehensive stats since this is error recovery)
            winnerStats.rating = newWinnerRating; loserStats.rating = newLoserRating;
            winnerStats.rd = newWinnerRd; loserStats.rd = newLoserRd;
            winnerStats.volatility = newWinnerVolatility; loserStats.volatility = newLoserVolatility;
            winnerStats.battles++; winnerStats.wins++; loserStats.battles++; loserStats.losses++; totalBattlesCount++;
            recordBattle(currentBattle[0], currentBattle[1], winner.naam, loser.naam); // Basic record without stats
            saveData(); updateRanking(); displayBattle(); isProcessingChoice = false;
            resolvingBattle = false;
        });
    }

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
        if (!currentUser) return;
        
        // Number key navigation (1-4 for tabs)
        if (['1', '2', '3', '4', '5'].includes(event.key)) {
            event.preventDefault();
            const tabMap = {
                '1': 'home',
                '2': 'battle',
                '3': 'ranking',
                '4': 'history',
                '5': 'achievements'
            };
            achievementManager.usedNumberKeys = 1;
            switchTab(tabMap[event.key]);
            achievementManager.save(currentUser);
            checkAndShowAchievements();
            return;
        }
        
        const battleTab = document.getElementById('battle-tab');
        if (!battleTab.classList.contains('active')) return;
        
        if (event.key === 'ArrowLeft') {
            event.preventDefault();
            achievementManager.usedKeyboard = 1;
            // Detect keyboard usage for more aggressive preloading
            if (!keyboardUsageDetected) {
                keyboardUsageDetected = true;
                console.log('üöÄ Keyboard mode detected - increasing preload queue');
            }
            chooseWinner(0);
        } else if (event.key === 'ArrowRight') {
            event.preventDefault();
            achievementManager.usedKeyboard = 1;
            // Detect keyboard usage for more aggressive preloading
            if (!keyboardUsageDetected) {
                keyboardUsageDetected = true;
                console.log('üöÄ Keyboard mode detected - increasing preload queue');
            }
            chooseWinner(1);
        }
    });

    // Close keyboard hint and persist preference
    function closeKeyboardHint() {
        const hint = document.getElementById('keyboardHint');
        if (hint) {
            hint.classList.add('hidden');
            localStorage.setItem('keyboardHintDismissed', 'true');
        }
    }

    // Check if hint was previously dismissed and sync simulate input width on load
    window.addEventListener('DOMContentLoaded', () => {
        const dismissed = localStorage.getItem('keyboardHintDismissed');
        if (dismissed === 'true') {
            const hint = document.getElementById('keyboardHint');
            if (hint) hint.classList.add('hidden');
        }
        // sync simulate input to button width immediately after DOM ready
        try { syncSimInputWidth(); } catch (e) {}
        // populate lightweight DOM cache
        try {
            DOM.battleContainer = $id('battleContainer');
            DOM.simulateBtn = $id('simulateBtn');
            DOM.simulateCount = $id('simulateCount');
        } catch (e) { /* ignore */ }
        // attempt to load coaster CSV data (fetch). If this fails, a fallback file-input UI will be shown.
        try {
            loadCoasterData();
        } catch (e) {
            // ensure the battle view is consistent even if loadCoasterData throws
            try { displayBattle(); } catch (ee) {}
        }

        // Initialize achievements display if a user was previously selected
        const lastUser = localStorage.getItem('lastUser');
        if (lastUser && typeof achievementManager !== 'undefined') {
            setTimeout(() => {
                if (currentUser) {
                    updateAchievementsTab();
                }
            }, 100);
        }

        // Dev toggle uses inline onclick; no extra listener needed here.
    });

    // Global undo for history deletes: Cmd+Z / Ctrl+Z (but not when typing in an input)
    function undoLastDelete() {
        if (!deletedHistoryStack || deletedHistoryStack.length === 0) return false;
        const item = deletedHistoryStack.pop();
        if (!item || !item.entry) return false;

        // Re-insert at original index where possible, otherwise append
        const insertIndex = (typeof item.index === 'number' && item.index >= 0 && item.index <= coasterHistory.length) ? item.index : coasterHistory.length;
        coasterHistory.splice(insertIndex, 0, item.entry);
        saveData();
        displayHistory();
        // Show a small toast confirming undo (include restored pair)
        try {
            const a = item.entry && item.entry.a ? item.entry.a : '';
            const b = item.entry && item.entry.b ? item.entry.b : '';
            showToast(`Hersteld: ${a} ‚Üî ${b}`);
        } catch (e) {
            showToast('Hersteld: matchup teruggezet');
        }
        return true;
    }

    document.addEventListener('keydown', (ev) => {
        // Ignore undo while focused on text inputs or contenteditable areas
        const active = document.activeElement;
        if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

        const isUndo = (ev.key && ev.key.toLowerCase() === 'z') && (ev.metaKey || ev.ctrlKey);
        if (!isUndo) return;

        // Only act when there's a history tab or current user
        if (!currentUser) return;

        const handled = undoLastDelete();
        if (handled) {
            ev.preventDefault();
        }
    });

    // ============================================
    // HOME TAB FUNCTIONALITY
    // ============================================

    // Daily quest tracking
    let dailyQuestProgress = 0;
    let lastQuestResetDate = null;

    function loadDailyQuest() {
        if (!currentUser) return;
        
        const today = new Date().toDateString();
        const savedDate = localStorage.getItem(`dailyQuestDate_${currentUser}`);
        const savedProgress = parseInt(localStorage.getItem(`dailyQuestProgress_${currentUser}`)) || 0;
        
        // Reset if it's a new day
        if (savedDate !== today) {
            dailyQuestProgress = 0;
            localStorage.setItem(`dailyQuestDate_${currentUser}`, today);
            localStorage.setItem(`dailyQuestProgress_${currentUser}`, '0');
        } else {
            dailyQuestProgress = savedProgress;
        }
        
        lastQuestResetDate = today;
    }

    function updateDailyQuest() {
        if (!currentUser) return;
        
        const today = new Date().toDateString();
        
        // Check if we need to reset for a new day
        if (lastQuestResetDate !== today) {
            loadDailyQuest();
        }
        
        dailyQuestProgress = Math.min(dailyQuestProgress + 1, 25);
        localStorage.setItem(`dailyQuestProgress_${currentUser}`, dailyQuestProgress.toString());
        
        // Update UI if on home tab
        const questFill = document.getElementById('questProgressFill');
        const questText = document.getElementById('questProgressText');
        
        if (questFill && questText) {
            const percentage = (dailyQuestProgress / 25) * 100;
            questFill.style.width = percentage + '%';
            questText.textContent = `${dailyQuestProgress}/25 battles`;
        }
    }

    // Session stats tracking
    let sessionBattles = 0;
    let sessionCloseFights = 0;

    function resetSessionStats() {
        sessionBattles = 0;
        sessionCloseFights = 0;
    }

    function updateSessionStats(isCloseFight = false) {
        sessionBattles++;
        if (isCloseFight) sessionCloseFights++;
        
        // Update UI if on home tab
        const sessionBattlesEl = document.getElementById('sessionBattles');
        const sessionCloseFightsEl = document.getElementById('sessionCloseFights');
        
        if (sessionBattlesEl) sessionBattlesEl.textContent = sessionBattles;
        if (sessionCloseFightsEl) sessionCloseFightsEl.textContent = sessionCloseFights;
    }

    function displayHome() {
        if (!currentUser) {
            // Show welcome state without user
            const welcomeEl = document.getElementById('homeWelcome');
            if (welcomeEl) welcomeEl.textContent = 'Welcome to Coaster Ranker!';
            
            // Show placeholder content
            document.getElementById('homeTotalBattles').textContent = '0';
            document.getElementById('homeTotalCoasters').textContent = '0';
            document.getElementById('homeProgressMatchups').textContent = '0/0';
            document.getElementById('homeProgressPercentage').textContent = '0%';
            document.getElementById('questProgressFill').style.width = '0%';
            document.getElementById('questProgressText').textContent = '0/25 battles';
            document.getElementById('homeTop3').innerHTML = '<div class="no-battles">Select a user first! üëÜ</div>';
            document.getElementById('homeAchievementCount').textContent = '0/0';
            document.getElementById('homeRecentAchievements').innerHTML = '';
            document.getElementById('sessionBattles').textContent = '0';
            document.getElementById('sessionCloseFights').textContent = '0';
            return;
        }

        // Update welcome message
        const welcomeEl = document.getElementById('homeWelcome');
        const userName = currentUser.charAt(0).toUpperCase() + currentUser.slice(1);
        if (welcomeEl) welcomeEl.textContent = `Welcome, ${userName}!`;

        // Update profile stats (moved from ranking tab)
        const statsArray = Object.values(coasterStats);
        const totalCoasters = statsArray.length;
        const totalBattles = totalBattlesCount;
        
        const totalPossible = getTotalPossiblePairs();
        const completed = completedPairs.size;
        const progressPercentage = totalPossible > 0 ? ((completed / totalPossible) * 100).toFixed(1) : 0;
        
        document.getElementById('homeTotalBattles').textContent = totalBattles;
        document.getElementById('homeTotalCoasters').textContent = totalCoasters;
        document.getElementById('homeProgressMatchups').textContent = `${completed}/${totalPossible}`;
        document.getElementById('homeProgressPercentage').textContent = `${progressPercentage}%`;

    // Update ranking tab stats bar
    const rankingTotalCoasters = document.getElementById('rankingTotalCoasters');
    const rankingProgressMatchups = document.getElementById('rankingProgressMatchups');
    if (rankingTotalCoasters) rankingTotalCoasters.textContent = totalCoasters;
    if (rankingProgressMatchups) rankingProgressMatchups.textContent = `${completed}/${totalPossible}`;

        // Update daily quest
        loadDailyQuest();
        const questPercentage = (dailyQuestProgress / 25) * 100;
        document.getElementById('questProgressFill').style.width = questPercentage + '%';
        document.getElementById('questProgressText').textContent = `${dailyQuestProgress}/25 battles`;

        // Update top 3 coasters
        const top3Container = document.getElementById('homeTop3');
        if (totalBattles === 0) {
            top3Container.innerHTML = '<div class="no-battles">Start battling to see your favorites!</div>';
        } else {
            const sorted = [...statsArray].sort((a, b) => displayedRating(b) - displayedRating(a));
            const top3 = sorted.slice(0, 3);
            
            const html = top3.map((coaster, index) => {
                const rank = index + 1;
                const rankClass = `rank-${rank}`;
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â';
                return `
                    <div class="top-coaster-item">
                        <div class="top-coaster-rank ${rankClass}">${medal}</div>
                        <div class="top-coaster-info">
                            <div class="top-coaster-name">${coaster.name}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            top3Container.innerHTML = html;
        }

        // Update achievements
        try {
            const totalAchievements = Object.keys(ACHIEVEMENTS).length;
            const unlockedCount = achievementManager.getUnlockedCount();
            document.getElementById('homeAchievementCount').textContent = `${unlockedCount}/${totalAchievements}`;
            
            // Show 3 most recent achievements
            const recent = achievementManager.getRecentAchievements(3);
            const recentHtml = recent.map(ach => 
                `<div class="recent-achievement-icon" title="${ach.name}">${ach.icon}</div>`
            ).join('');
            document.getElementById('homeRecentAchievements').innerHTML = recentHtml || '<div style="text-align:center;color:#999;font-size:0.9em;">No achievements yet</div>';
        } catch (e) {
            document.getElementById('homeAchievementCount').textContent = '0/0';
            document.getElementById('homeRecentAchievements').innerHTML = '';
        }

        // Update session stats
        document.getElementById('sessionBattles').textContent = sessionBattles;
        document.getElementById('sessionCloseFights').textContent = sessionCloseFights;
        
        // Match tab heights after content is rendered
        setTimeout(() => matchTabHeights(), 50);
    }

    function matchTabHeights() {
        // Match all tabs to profile tab height
        const profileTab = document.getElementById('home-tab');
        const battleTab = document.getElementById('battle-tab');
        const rankingTab = document.getElementById('ranking-tab');
        const historyTab = document.getElementById('history-tab');
        const achievementsTab = document.getElementById('achievements-tab');
        
        if (profileTab) {
            // Temporarily make profile visible to measure it
            const wasProfileActive = profileTab.classList.contains('active');
            
            // Make profile visible (but keep it off-screen if it wasn't active)
            if (!wasProfileActive) {
                profileTab.style.position = 'absolute';
                profileTab.style.visibility = 'hidden';
                profileTab.style.display = 'block';
            }
            
            // Force a reflow to ensure measurement is accurate
            profileTab.offsetHeight;
            
            // Get the actual computed height of the profile tab
            const profileHeight = profileTab.scrollHeight;
            
            // Restore profile tab state
            if (!wasProfileActive) {
                profileTab.style.position = '';
                profileTab.style.visibility = '';
                profileTab.style.display = '';
            }
            
            // Set all tabs to match (use height, not min-height, to force exact match)
            // Enable overflow-y auto so content scrolls instead of the page
            if (battleTab) {
                battleTab.style.height = profileHeight + 'px';
                battleTab.style.overflowY = 'hidden';
            }
            if (rankingTab) {
                rankingTab.style.height = profileHeight + 'px';
                rankingTab.style.overflowY = 'auto';
            }
            if (historyTab) {
                historyTab.style.height = profileHeight + 'px';
                historyTab.style.overflowY = 'auto';
            }
            if (achievementsTab) {
                achievementsTab.style.height = profileHeight + 'px';
                achievementsTab.style.overflowY = 'auto';
            }
        }
    }

    function switchTab(tabName) {
        // Save the current tab to localStorage
        try {
            localStorage.setItem('lastActiveTab', tabName);
        } catch (e) { /* ignore */ }
        
        // Always hide close battle overlay when switching tabs
        try {
            cancelCloseIntro();
            const overlay = document.getElementById('closeBattleOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                overlay.style.display = 'none';
            }
        } catch (e) { /* ignore */ }
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Find and activate the corresponding tab button
        const tabButtons = document.querySelectorAll('.tab');
        const tabMap = ['home', 'battle', 'ranking', 'history', 'achievements'];
        const tabIndex = tabMap.indexOf(tabName);
        if (tabIndex >= 0 && tabButtons[tabIndex]) {
            tabButtons[tabIndex].classList.add('active');
        }
        
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tabName + '-tab').classList.add('active');
        // Refresh relevant tab content
        if (tabName === 'battle') {
            // Ensure battle view is up-to-date
            try { displayBattle(); } catch (e) {}
            // show battle UI
            try { setBattleVisibility(true); } catch (e) {}
        } else {
            // Hide battle cards when not on the battle tab
            try { setBattleVisibility(false); } catch (e) {}
        }

        if (tabName === 'home') {
            displayHome();
        } else if (tabName === 'ranking') {
            updateRanking();
        } else if (tabName === 'history') {
            displayHistory();
        } else if (tabName === 'achievements') {
            console.log('Switching to achievements tab');
            const achievementsTab = document.getElementById('achievements-tab');
            console.log('Achievements tab element:', achievementsTab);
            console.log('Achievements tab has active class:', achievementsTab ? achievementsTab.classList.contains('active') : 'element not found');
            updateAchievementsTab();
        }
        
        // Match tab heights after switching and content is rendered
        setTimeout(() => matchTabHeights(), 50);
    }

    // Render the history in the history tab
    function displayHistory() {
        const container = document.getElementById('historyContainer');
        if (!container) return;
        if (!coasterHistory || coasterHistory.length === 0) {
            container.innerHTML = '<div class="no-battles">No battles yet ‚Äî start choosing to build your history.</div>';
            return;
        }
        const query = document.getElementById('historySearch') ? document.getElementById('historySearch').value.trim() : '';
        const qLower = (query || '').toLowerCase();
        const hasSelected = !!qLower;

        // Ensure filter UI reflects whether a coaster is selected
        updateHistoryFilterUI();

        // Render only pair, highlight winner with a green pill and add a subtle delete button
        const rows = coasterHistory.slice().reverse().map((entry, idx) => {
            const originalIndex = coasterHistory.length - 1 - idx;
            // Use stored left/right positions if available, otherwise fall back to a/b
            let a = entry.left || entry.a;
            let b = entry.right || entry.b;
            const winner = entry.winner;

            const pairText = `${a} ‚Üî ${b}`;
            // If there's a search query, only show rows that include the query
            if (qLower && !pairText.toLowerCase().includes(qLower) && !a.toLowerCase().includes(qLower) && !b.toLowerCase().includes(qLower)) {
                return '';
            }

            // If there's a search query, put the matching coaster on the left
            if (qLower) {
                const aMatches = a.toLowerCase().includes(qLower);
                const bMatches = b.toLowerCase().includes(qLower);
                // If only b matches, swap them so the selected coaster appears left
                if (!aMatches && bMatches) {
                    [a, b] = [b, a];
                }
            }

            // Apply active filter
            if (typeof historyFilter !== 'undefined' && historyFilter && historyFilter !== 'all') {
                const selectedName = query;
                if (historyFilter === 'wins') {
                    // only show battles where selectedName is the winner (requires selected coaster)
                    if (!hasSelected || winner !== selectedName) return '';
                } else if (historyFilter === 'losses') {
                    // only show battles where selectedName lost (requires selected coaster)
                    if (!hasSelected || winner === selectedName) return '';
                    if (a !== selectedName && b !== selectedName) return '';
                } else if (historyFilter === 'close') {
                    // show all close fights (or only those involving selected coaster if one is selected)
                    if (!entry.closeFight) return '';
                    if (hasSelected && a !== selectedName && b !== selectedName) return '';
                }
            }

            const winnerClass = (entry && entry.closeFight) ? 'winner-pill close-win' : 'winner-pill';
            const aHtml = (winner === a) ? `<span class="clickable-history-name" onclick="viewCoasterHistory('${a.replace(/'/g, "\\'")}')" style="cursor:pointer;"><span class="${winnerClass}">${escapeHtml(a)}</span></span>` : `<span class="clickable-history-name" onclick="viewCoasterHistory('${a.replace(/'/g, "\\'")}')" style="cursor:pointer;">${escapeHtml(a)}</span>`;
            const bHtml = (winner === b) ? `<span class="clickable-history-name" onclick="viewCoasterHistory('${b.replace(/'/g, "\\'")}')" style="cursor:pointer;"><span class="${winnerClass}">${escapeHtml(b)}</span></span>` : `<span class="clickable-history-name" onclick="viewCoasterHistory('${b.replace(/'/g, "\\'")}')" style="cursor:pointer;">${escapeHtml(b)}</span>`;

            const arrowHtml = entry && entry.closeFight ? `<span class="close-fight-icon" title="Close fight">‚öîÔ∏è</span>` : '‚Üî';

            return `
                <div class="history-row">
                    <div class="history-pair">
                        <div class="history-name left"><strong>${aHtml}</strong></div>
                        <div class="history-arrow">${arrowHtml}</div>
                        <div class="history-name right"><strong>${bHtml}</strong></div>
                    </div>
                    <div class="history-actions">
                        <button class="history-switch" title="Switch winner" onclick="switchHistoryWinner(${originalIndex})">‚áÑ</button>
                        <button class="history-delete" title="Delete this matchup" onclick="deleteHistoryEntry(${originalIndex})">‚úñ</button>
                    </div>
                </div>
            `;
        }).join('');

        // If filtering removed all rows, show empty state
        if (!rows || rows.trim() === '') {
            container.innerHTML = '<div class="no-battles">No matchups found for this search.</div>';
        } else {
            container.innerHTML = rows;
        }
        
        // Match tab heights after content is rendered
        setTimeout(() => matchTabHeights(), 50);
    }

    let selectedAutocompleteIndex = -1;
    // History filter state: 'all' | 'wins' | 'losses' | 'close'
    let historyFilter = 'all';
    // Track if user actually selected a coaster (vs just typing)
    let coasterSelected = false;

    function setHistoryFilter(filter) {
        if (!filter) return;
        historyFilter = filter;
        // update active class on buttons
        const btns = document.querySelectorAll('#historyFilters .filter-btn');
        btns.forEach(b => {
            const f = b.getAttribute('data-filter');
            if (f === filter) b.classList.add('active'); else b.classList.remove('active');
        });
        // refresh displayed history
        displayHistory();
    }

    function updateHistoryFilterUI() {
        const input = document.getElementById('historySearch');
        const historyFilters = document.getElementById('historyFilters');
        if (!historyFilters) return;
        if (coasterSelected) {
            document.body.classList.add('coaster-selected');
        } else {
            document.body.classList.remove('coaster-selected');
            // reset to 'all' when no coaster selected (wins/losses won't make sense)
            if (historyFilter === 'wins' || historyFilter === 'losses') {
                historyFilter = 'all';
                const btns = historyFilters.querySelectorAll('.filter-btn');
                btns.forEach(b => { b.classList.remove('active'); });
                const first = historyFilters.querySelector('.filter-btn[data-filter="all"]');
                if (first) first.classList.add('active');
            }
        }
    }

    function getHistoryAutocompleteSuggestions() {
        const coasterNames = new Set();
        Object.keys(coasterStats).forEach(name => coasterNames.add(name));
        return Array.from(coasterNames).sort();
    }

    function handleHistorySearchInput() {
        const input = document.getElementById('historySearch');
        const clearBtn = document.getElementById('clearHistorySearchBtn');
        clearBtn.style.display = input.value.trim() ? 'block' : 'none';
        coasterSelected = false; // Reset when typing
        showHistoryAutocomplete();
        updateHistoryFilterUI();
    }

    function clearHistorySearch() {
        const input = document.getElementById('historySearch');
        const clearBtn = document.getElementById('clearHistorySearchBtn');
        input.value = '';
        clearBtn.style.display = 'none';
        const dropdown = document.getElementById('historyAutocomplete');
        dropdown.classList.remove('show');
        coasterSelected = false;
        displayHistory();
        updateHistoryFilterUI();
    }

    function showHistoryAutocomplete() {
        const input = document.getElementById('historySearch');
        const dropdown = document.getElementById('historyAutocomplete');
        const query = input.value.trim().toLowerCase();
        
        const allSuggestions = getHistoryAutocompleteSuggestions();
        const filteredSuggestions = query === '' 
            ? allSuggestions 
            : allSuggestions.filter(name => name.toLowerCase().includes(query));
        
        if (filteredSuggestions.length === 0) {
            dropdown.classList.remove('show');
            return;
        }
        
        dropdown.innerHTML = filteredSuggestions.map((name, idx) => 
            `<div class="autocomplete-item" data-index="${idx}" onclick="selectHistorySuggestion('${name.replace(/'/g, "\\'")}')">${escapeHtml(name)}</div>`
        ).join('');
        
        dropdown.classList.add('show');
        selectedAutocompleteIndex = -1;
    }

    function selectHistorySuggestion(name) {
        const input = document.getElementById('historySearch');
        const clearBtn = document.getElementById('clearHistorySearchBtn');
        input.value = name;
        clearBtn.style.display = 'block';
        document.getElementById('historyAutocomplete').classList.remove('show');
        coasterSelected = true;
        displayHistory();
        updateHistoryFilterUI();
    }

    function handleHistorySearchKeydown(event) {
        const dropdown = document.getElementById('historyAutocomplete');
        const items = dropdown.querySelectorAll('.autocomplete-item');
        
        if (!dropdown.classList.contains('show') || items.length === 0) return;
        
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
            updateAutocompleteSelection(items);
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
            updateAutocompleteSelection(items);
        } else if (event.key === 'Enter') {
            event.preventDefault();
            if (selectedAutocompleteIndex >= 0 && selectedAutocompleteIndex < items.length) {
                items[selectedAutocompleteIndex].click();
            }
        } else if (event.key === 'Escape') {
            dropdown.classList.remove('show');
        }
    }

    function updateAutocompleteSelection(items) {
        items.forEach((item, idx) => {
            if (idx === selectedAutocompleteIndex) {
                item.classList.add('selected');
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.classList.remove('selected');
            }
        });
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (event) => {
        const dropdown = document.getElementById('historyAutocomplete');
        const input = document.getElementById('historySearch');
        if (dropdown && input && !input.contains(event.target) && !dropdown.contains(event.target)) {
            dropdown.classList.remove('show');
        }
    });

    // delete a single history entry by its index in coasterHistory
    function deleteHistoryEntry(index) {
        if (typeof index !== 'number' || index < 0 || index >= coasterHistory.length) return;

        const removed = coasterHistory.splice(index, 1)[0];
        
        // Remove from completed pairs to allow re-matching
        if (removed.pairKey) {
            completedPairs.delete(removed.pairKey);
        }

        // push onto undo stack
        try {
            deletedHistoryStack.push({ entry: removed, index });
            if (deletedHistoryStack.length > MAX_UNDO_STACK) deletedHistoryStack.shift();
        } catch (e) {
            // fallback: if something goes wrong with stack, ignore
        }

        saveData();
        displayHistory();
        displayBattle(); // Refresh battle view in case new pairs are available
        // show toast confirming deletion
        try {
            showToast(`Removed: ${removed.a} ‚Üî ${removed.b}`);
        } catch (e) {}
    }

    // switch the winner in a history entry
    function switchHistoryWinner(index) {
        if (typeof index !== 'number' || index < 0 || index >= coasterHistory.length) return;

        const entry = coasterHistory[index];
        const oldWinner = entry.winner;
        const newWinner = (entry.winner === entry.a) ? entry.b : entry.a;
        const oldLoser = newWinner; // The new winner was the old loser
        
        console.log('=== SWITCHING WINNER ===');
        console.log('Old winner:', oldWinner);
        console.log('New winner:', newWinner);
        
        // Get current ranks before switching
        const oldWinnerRankBefore = getCoasterRank(oldWinner);
        const newWinnerRankBefore = getCoasterRank(newWinner);
        
        console.log('Current ranks before switch:', {
            [oldWinner]: oldWinnerRankBefore,
            [newWinner]: newWinnerRankBefore
        });
        
        // Update the winner in the history entry
        entry.winner = newWinner;
        entry.loser = oldWinner;
        
        // Update ratings by reversing the previous outcome
        const winnerStats = coasterStats[oldWinner];
        const loserStats = coasterStats[newWinner];
        
        if (winnerStats && loserStats && entry.statsA && entry.statsB) {
            console.log('Current rating before restoration:', {
                [oldWinner]: winnerStats.rating,
                [newWinner]: loserStats.rating
            });
            
            // Restore rating to BEFORE this battle happened (to avoid compounding errors)
            const aStats = coasterStats[entry.a];
            const bStats = coasterStats[entry.b];
            
            if (aStats && bStats) {
                // Restore from stored battle stats (support both old ELO and new Glicko-2)
                aStats.rating = entry.statsA.ratingBefore || entry.statsA.eloBefore || aStats.rating;
                aStats.rd = entry.statsA.rdBefore || GLICKO2_RD_INITIAL;
                aStats.volatility = entry.statsA.volatilityBefore || GLICKO2_VOLATILITY_INITIAL;
                bStats.rating = entry.statsB.ratingBefore || entry.statsB.eloBefore || bStats.rating;
                bStats.rd = entry.statsB.rdBefore || GLICKO2_RD_INITIAL;
                bStats.volatility = entry.statsB.volatilityBefore || GLICKO2_VOLATILITY_INITIAL;
                
                console.log('Restored rating to pre-battle state:', {
                    [entry.a]: aStats.rating,
                    [entry.b]: bStats.rating
                });
            }
            
            // Reverse old outcome
            winnerStats.wins--;
            loserStats.losses--;
            
            console.log('Reversed win/loss counts:', {
                [oldWinner]: { wins: winnerStats.wins, losses: winnerStats.losses },
                [newWinner]: { wins: loserStats.wins, losses: loserStats.losses }
            });
            
            // Apply new outcome
            loserStats.wins++;
            winnerStats.losses++;
            
            console.log('Applied new outcome:', {
                [oldWinner]: { wins: winnerStats.wins, losses: winnerStats.losses },
                [newWinner]: { wins: loserStats.wins, losses: loserStats.losses }
            });
            
            // Now recalculate rating from the original before-battle state with new winner
            const newWinnerStats = coasterStats[newWinner];
            const oldWinnerStats = coasterStats[oldWinner];
            
            const glickoOutcome = calculateGlicko2(newWinnerStats, oldWinnerStats);
            const { newWinnerRating, newWinnerRD, newWinnerVolatility, newLoserRating, newLoserRD, newLoserVolatility } = glickoOutcome;
            
            console.log('Recalculated rating:', {
                [newWinner]: `${newWinnerStats.rating} ‚Üí ${newWinnerRating}`,
                [oldWinner]: `${oldWinnerStats.rating} ‚Üí ${newLoserRating}`
            });
            
            newWinnerStats.rating = newWinnerRating;
            newWinnerStats.rd = newWinnerRD;
            newWinnerStats.volatility = newWinnerVolatility;
            oldWinnerStats.rating = newLoserRating;
            oldWinnerStats.rd = newLoserRD;
            oldWinnerStats.volatility = newLoserVolatility;
            
            // Update comprehensive battle stats if they exist
            if (entry.statsA && entry.statsB) {
                // Get new ranks after switching
                const oldWinnerRankAfter = getCoasterRank(oldWinner);
                const newWinnerRankAfter = getCoasterRank(newWinner);
                
                // Swap the winner/loser data in statsA and statsB
                const isAtheNewWinner = (entry.a === newWinner);
                
                // Store original values before swapping
                const origStatsA = {
                    potentialGain: entry.statsA.potentialGain,
                    potentialLoss: entry.statsA.potentialLoss
                };
                const origStatsB = {
                    potentialGain: entry.statsB.potentialGain,
                    potentialLoss: entry.statsB.potentialLoss
                };
                
                if (isAtheNewWinner) {
                    // A is now winner, B is now loser - update their after-battle values
                    entry.statsA.ratingAfter = newWinnerStats.rating;
                    entry.statsA.rdAfter = newWinnerStats.rd;
                    entry.statsA.volatilityAfter = newWinnerStats.volatility;
                    entry.statsA.rankAfter = newWinnerRankAfter;
                    // Swap: A's new potentialGain/Loss comes from B's old values
                    entry.statsA.potentialGain = origStatsB.potentialGain;
                    entry.statsA.potentialLoss = origStatsB.potentialLoss;
                    
                    entry.statsB.ratingAfter = oldWinnerStats.rating;
                    entry.statsB.rdAfter = oldWinnerStats.rd;
                    entry.statsB.volatilityAfter = oldWinnerStats.volatility;
                    entry.statsB.rankAfter = oldWinnerRankAfter;
                    // Swap: B's new potentialGain/Loss comes from A's old values
                    entry.statsB.potentialGain = origStatsA.potentialGain;
                    entry.statsB.potentialLoss = origStatsA.potentialLoss;
                } else {
                    // B is now winner, A is now loser
                    entry.statsB.ratingAfter = newWinnerStats.rating;
                    entry.statsB.rdAfter = newWinnerStats.rd;
                    entry.statsB.volatilityAfter = newWinnerStats.volatility;
                    entry.statsB.rankAfter = newWinnerRankAfter;
                    // Swap: B's new potentialGain/Loss comes from A's old values
                    entry.statsB.potentialGain = origStatsA.potentialGain;
                    entry.statsB.potentialLoss = origStatsA.potentialLoss;
                    
                    entry.statsA.ratingAfter = oldWinnerStats.rating;
                    entry.statsA.rdAfter = oldWinnerStats.rd;
                    entry.statsA.volatilityAfter = oldWinnerStats.volatility;
                    entry.statsA.rankAfter = oldWinnerRankAfter;
                    // Swap: A's new potentialGain/Loss comes from B's old values
                    entry.statsA.potentialGain = origStatsB.potentialGain;
                    entry.statsA.potentialLoss = origStatsB.potentialLoss;
                }
                
                console.log('Updated battle stats:', {
                    statsA: {
                        name: entry.a,
                        ratingAfter: entry.statsA.ratingAfter,
                        rankAfter: entry.statsA.rankAfter,
                        potentialGain: entry.statsA.potentialGain,
                        potentialLoss: entry.statsA.potentialLoss
                    },
                    statsB: {
                        name: entry.b,
                        ratingAfter: entry.statsB.ratingAfter,
                        rankAfter: entry.statsB.rankAfter,
                        potentialGain: entry.statsB.potentialGain,
                        potentialLoss: entry.statsB.potentialLoss
                    }
                });
            }
        }
        
        saveData();
        displayHistory();
        updateRanking();
        
        // Get new ranks after switching for toast message
        const oldWinnerRankAfter = getCoasterRank(oldWinner);
        const newWinnerRankAfter = getCoasterRank(newWinner);
        
        console.log('Final ranks after switch:', {
            [oldWinner]: oldWinnerRankAfter,
            [newWinner]: newWinnerRankAfter
        });
        console.log('=== SWITCH COMPLETE ===\n');
        
        // Simple toast message
        showToast(`Winner switched: ${newWinner} now wins against ${oldWinner}`);
    }

    // small helper to escape HTML in names
    function escapeHtml(str) {
        return String(str).replace(/[&<>"']/g, function (s) {
            return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s];
        });
    }

    // Toast helper: show a small non-blocking message at bottom-center
    function showToast(message, duration = 2400) {
        try {
            const existing = document.querySelector('.toast');
            if (existing) {
                existing.remove();
            }
            const t = document.createElement('div');
            t.className = 'toast';
            t.textContent = message;
            document.body.appendChild(t);
            // Force layout then add class to trigger transition
            void t.offsetWidth;
            t.classList.add('show');
            setTimeout(() => {
                t.classList.remove('show');
                setTimeout(() => t.remove(), 300);
            }, duration);
        } catch (e) {
            // ignore failures silently
        }
    }

    // clear history for user
    function clearHistory() {
        if (!currentUser) return;
        coasterHistory = [];
        saveData();
        displayHistory();
    }

    // export history JSON
    function exportHistory() {
        if (!coasterHistory || coasterHistory.length === 0) {
            alert('Geen history om te exporteren.');
            return;
        }
        const blob = new Blob([JSON.stringify(coasterHistory, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `coaster_history_${currentUser || 'anonymous'}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // Ranking Wizard: Recalculate all battles using current K-factors to correct for "lucky start"
    async function runRankingWizard() {
        if (!currentUser) {
            alert('Select a user first!');
            return;
        }
        
        if (!coasterHistory || coasterHistory.length === 0) {
            alert('No battle history to recalculate!');
            return;
        }
        
        console.log('üßô === RANKING WIZARD STARTED ===');
        console.log(`Total battles to recalculate: ${coasterHistory.length}`);
        
        const progressEl = document.getElementById('rankingWizardProgress');
        const wizardBtn = document.getElementById('rankingWizardBtn');
        
        if (wizardBtn) wizardBtn.disabled = true;
        
        let totalIterations = 0;
        let totalChanges = 0;
        const startTime = performance.now();
        
        try {
            // Keep running iterations until no coasters change position
            while (true) {
                totalIterations++;
                console.log(`\nüßô === ITERATION ${totalIterations} ===`);
                
                // Capture ranking positions before recalculation
                const ranksBefore = {};
                Object.values(coasterStats).forEach(stats => {
                    ranksBefore[stats.name] = getCoasterRank(stats.name);
                });
                
                if (progressEl) {
                    progressEl.style.display = 'block';
                    progressEl.textContent = `Iteration ${totalIterations}...`;
                }
                
                // Process each battle in chronological order
                for (let i = 0; i < coasterHistory.length; i++) {
                const entry = coasterHistory[i];
                const winner = entry.winner;
                const loser = entry.loser || (entry.winner === entry.a ? entry.b : entry.a);
                
                // Skip battles without comprehensive stats (from before the update)
                if (!entry.statsA || !entry.statsB) {
                    console.log(`Battle ${i+1}: Missing statsA/statsB (old battle), skipping...`);
                    continue;
                }
                
                // Get stats (they should exist, but check anyway)
                const winnerStats = coasterStats[winner];
                const loserStats = coasterStats[loser];
                
                if (!winnerStats || !loserStats) {
                    console.warn(`Battle ${i+1}: Missing stats for ${winner} or ${loser}, skipping...`);
                    continue;
                }
                
                // Step A: Restore rating/RD/volatility to BEFORE this battle by using stored values
                // Support backward compatibility: check both old (eloBefore) and new (ratingBefore) fields
                const winnerRatingBefore = entry.statsA && entry.a === winner ? 
                                          (entry.statsA.ratingBefore !== undefined ? entry.statsA.ratingBefore : entry.statsA.eloBefore) :
                                          entry.statsB && entry.b === winner ?
                                          (entry.statsB.ratingBefore !== undefined ? entry.statsB.ratingBefore : entry.statsB.eloBefore) :
                                          winnerStats.rating;
                const loserRatingBefore = entry.statsA && entry.a === loser ?
                                         (entry.statsA.ratingBefore !== undefined ? entry.statsA.ratingBefore : entry.statsA.eloBefore) :
                                         entry.statsB && entry.b === loser ?
                                         (entry.statsB.ratingBefore !== undefined ? entry.statsB.ratingBefore : entry.statsB.eloBefore) :
                                         loserStats.rating;
                
                const winnerRdBefore = entry.statsA && entry.a === winner ? 
                                      (entry.statsA.rdBefore || GLICKO2_RD_INITIAL) :
                                      entry.statsB && entry.b === winner ?
                                      (entry.statsB.rdBefore || GLICKO2_RD_INITIAL) :
                                      winnerStats.rd;
                const loserRdBefore = entry.statsA && entry.a === loser ?
                                     (entry.statsA.rdBefore || GLICKO2_RD_INITIAL) :
                                     entry.statsB && entry.b === loser ?
                                     (entry.statsB.rdBefore || GLICKO2_RD_INITIAL) :
                                     loserStats.rd;
                
                const winnerVolatilityBefore = entry.statsA && entry.a === winner ?
                                              (entry.statsA.volatilityBefore || GLICKO2_VOLATILITY_INITIAL) :
                                              entry.statsB && entry.b === winner ?
                                              (entry.statsB.volatilityBefore || GLICKO2_VOLATILITY_INITIAL) :
                                              winnerStats.volatility;
                const loserVolatilityBefore = entry.statsA && entry.a === loser ?
                                             (entry.statsA.volatilityBefore || GLICKO2_VOLATILITY_INITIAL) :
                                             entry.statsB && entry.b === loser ?
                                             (entry.statsB.volatilityBefore || GLICKO2_VOLATILITY_INITIAL) :
                                             loserStats.volatility;
                
                // Recalculate using Glicko-2
                const result = calculateGlicko2(
                    winnerRatingBefore, winnerRdBefore, winnerVolatilityBefore,
                    loserRatingBefore, loserRdBefore, loserVolatilityBefore,
                    1.0 // winner wins
                );
                
                // Apply new ratings
                winnerStats.rating = result.rating1;
                winnerStats.rd = result.rd1;
                winnerStats.volatility = result.volatility1;
                loserStats.rating = result.rating2;
                loserStats.rd = result.rd2;
                loserStats.volatility = result.volatility2;
                
                // Get new ranks
                const winnerRankAfter = getCoasterRank(winner);
                const loserRankAfter = getCoasterRank(loser);
                
                // Calculate potential gains/losses (needed for logging and stats update)
                const winnerPotentialGain = result.rating1 - winnerRatingBefore;
                const loserPotentialLoss = result.rating2 - loserRatingBefore;
                
                // Calculate what would have happened if outcome was reversed
                const reversedResult = calculateGlicko2(
                    winnerRatingBefore, winnerRdBefore, winnerVolatilityBefore,
                    loserRatingBefore, loserRdBefore, loserVolatilityBefore,
                    0.0 // winner loses
                );
                const winnerPotentialLoss = reversedResult.rating1 - winnerRatingBefore;
                const loserPotentialGain = reversedResult.rating2 - loserRatingBefore;
                
                // Update battle stats in history
                if (entry.statsA && entry.statsB) {
                    // Update ratingBefore/rdBefore/volatilityBefore with the restored values
                    entry.statsA.ratingBefore = (entry.a === winner) ? winnerRatingBefore : loserRatingBefore;
                    entry.statsB.ratingBefore = (entry.b === winner) ? winnerRatingBefore : loserRatingBefore;
                    entry.statsA.rdBefore = (entry.a === winner) ? winnerRdBefore : loserRdBefore;
                    entry.statsB.rdBefore = (entry.b === winner) ? winnerRdBefore : loserRdBefore;
                    entry.statsA.volatilityBefore = (entry.a === winner) ? winnerVolatilityBefore : loserVolatilityBefore;
                    entry.statsB.volatilityBefore = (entry.b === winner) ? winnerVolatilityBefore : loserVolatilityBefore;
                    
                    // Update ratingAfter/rdAfter/volatilityAfter with recalculated values
                    entry.statsA.ratingAfter = (entry.a === winner) ? result.rating1 : result.rating2;
                    entry.statsB.ratingAfter = (entry.b === winner) ? result.rating1 : result.rating2;
                    entry.statsA.rdAfter = (entry.a === winner) ? result.rd1 : result.rd2;
                    entry.statsB.rdAfter = (entry.b === winner) ? result.rd1 : result.rd2;
                    entry.statsA.volatilityAfter = (entry.a === winner) ? result.volatility1 : result.volatility2;
                    entry.statsB.volatilityAfter = (entry.b === winner) ? result.volatility1 : result.volatility2;
                    
                    // Update ranks
                    entry.statsA.rankAfter = (entry.a === winner) ? winnerRankAfter : loserRankAfter;
                    entry.statsB.rankAfter = (entry.b === winner) ? winnerRankAfter : loserRankAfter;
                    
                    // Store potential gains/losses
                    entry.statsA.potentialGain = (entry.a === winner) ? winnerPotentialGain : loserPotentialGain;
                    entry.statsA.potentialLoss = (entry.a === winner) ? winnerPotentialLoss : loserPotentialLoss;
                    entry.statsB.potentialGain = (entry.b === winner) ? winnerPotentialGain : loserPotentialGain;
                    entry.statsB.potentialLoss = (entry.b === winner) ? winnerPotentialLoss : loserPotentialLoss;
                    
                    // Store expected win probabilities
                    entry.statsA.expectedWinProbability = (entry.a === winner) ? result.expectedScore1 : (1 - result.expectedScore1);
                    entry.statsB.expectedWinProbability = (entry.b === winner) ? result.expectedScore1 : (1 - result.expectedScore1);
                }
                
                // Update progress every 50 battles
                if (progressEl && (i + 1) % 50 === 0) {
                    progressEl.textContent = `Iteration ${totalIterations}: Processing battle ${i + 1}/${coasterHistory.length}...`;
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to UI
                }
            }
            
            // Save and update UI after each iteration
            saveData();
            updateRanking();
            
            // Count how many coasters changed ranking positions in this iteration
            let changedPositions = 0;
            Object.values(coasterStats).forEach(stats => {
                const rankAfter = getCoasterRank(stats.name);
                const rankBefore = ranksBefore[stats.name];
                if (rankBefore !== rankAfter) {
                    changedPositions++;
                    console.log(`${stats.name}: #${rankBefore} ‚Üí #${rankAfter}`);
                }
            });
            
            totalChanges += changedPositions;
            console.log(`üßô Iteration ${totalIterations} complete: ${changedPositions} coasters changed position.`);
            
            // If no changes, we're done
            if (changedPositions === 0) {
                console.log('üßô No more changes detected. Wizard converged!');
                break;
            }
            
            // Small delay between iterations for UI updates
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Calculate total time
        const endTime = performance.now();
        const totalTime = ((endTime - startTime) / 1000).toFixed(2); // Convert to seconds
        
        // Final summary
        if (progressEl) {
            progressEl.textContent = `‚úÖ Complete! ${totalIterations} iteration${totalIterations !== 1 ? 's' : ''}, ${totalChanges} total changes.`;
            setTimeout(() => {
                progressEl.style.display = 'none';
                progressEl.textContent = '';
            }, 3000);
        }
        
        console.log('üßô === RANKING WIZARD COMPLETE ===');
        console.log(`Completed ${totalIterations} iterations with ${totalChanges} total ranking changes.`);
        console.log(`‚è±Ô∏è Total calculation time: ${totalTime}s`);
        
        showToast(`üßô Wizard complete! ${totalIterations} iteration${totalIterations !== 1 ? 's' : ''}, ${totalChanges} change${totalChanges !== 1 ? 's' : ''} in ${totalTime}s.`, 3500);
            
        } catch (error) {
            console.error('Ranking Wizard error:', error);
            if (progressEl) {
                progressEl.textContent = '‚ùå Error during recalculation';
                progressEl.style.color = '#e74c3c';
                setTimeout(() => {
                    progressEl.style.color = '';
                }, 3000);
            }
            alert('An error occurred during recalculation. Check console for details.');
        } finally {
            if (wizardBtn) wizardBtn.disabled = false;
        }
    }

    function sortRanking(column) {
        if (currentSort.column === column) {
            currentSort.ascending = !currentSort.ascending;
        } else {
            currentSort.column = column;
            currentSort.ascending = false;
        }
        updateRanking();
    }

    function updateRanking() {
        if (!currentUser) {
            document.getElementById('rankingBody').innerHTML = '<tr><td colspan="8" class="no-battles">Select a user first! üé¢</td></tr>';
            return;
        }
        
        const statsArray = Object.values(coasterStats);
        const totalCoasters = statsArray.length;
        const totalBattles = totalBattlesCount;
        const avgBattles = totalBattles > 0 ? (totalBattles * 2 / totalCoasters).toFixed(1) : 0;
        
        const totalPossible = getTotalPossiblePairs();
        const completed = completedPairs.size;
        const progressPercentage = totalPossible > 0 ? ((completed / totalPossible) * 100).toFixed(1) : 0;
        
        const totalBattlesEl = document.getElementById('totalBattles');
        const totalCoastersEl = document.getElementById('totalCoasters');
        const avgBattlesEl = document.getElementById('avgBattlesPerCoaster');
        const progressMatchupsEl = document.getElementById('progressMatchups');
        const progressPercentageEl = document.getElementById('progressPercentage');
        
        if (totalBattlesEl) totalBattlesEl.textContent = totalBattles;
        if (totalCoastersEl) totalCoastersEl.textContent = totalCoasters;
        if (avgBattlesEl) avgBattlesEl.textContent = avgBattles;
        if (progressMatchupsEl) progressMatchupsEl.textContent = `${completed}/${totalPossible}`;
        if (progressPercentageEl) progressPercentageEl.textContent = `${progressPercentage}%`;
        
        const sorted = [...statsArray].sort((a, b) => {
            let aVal, bVal;
            
            switch(currentSort.column) {
                case 'name':
                    aVal = a.name;
                    bVal = b.name;
                    break;
                case 'park':
                    aVal = a.park;
                    bVal = b.park;
                    break;
                case 'manufacturer':
                    aVal = a.manufacturer;
                    bVal = b.manufacturer;
                    break;
                case 'rating':
                case 'elo':
                    aVal = displayedRating(a);
                    bVal = displayedRating(b);
                    break;
                case 'battles':
                    aVal = a.battles;
                    bVal = b.battles;
                    break;
                case 'wins':
                    aVal = a.wins;
                    bVal = b.wins;
                    break;
                case 'losses':
                    aVal = a.losses;
                    bVal = b.losses;
                    break;
                case 'winrate':
                    aVal = a.battles > 0 ? (a.wins / a.battles) : 0;
                    bVal = b.battles > 0 ? (b.wins / b.battles) : 0;
                    break;
                default:
                    aVal = a.rating;
                    bVal = b.rating;
            }
            
            if (typeof aVal === 'string') {
                return currentSort.ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            } else {
                return currentSort.ascending ? aVal - bVal : bVal - aVal;
            }
        });
        
        document.querySelectorAll('.ranking-table th').forEach(th => {
            const text = th.textContent.replace(' ‚¨ÜÔ∏è', '').replace(' ‚¨áÔ∏è', '');
            th.textContent = text;
        });
        // Only add arrow for columns except 'rating'
        if (currentSort.column !== 'rating' && currentSort.column !== 'elo') {
            const activeHeader = Array.from(document.querySelectorAll('.ranking-table th'))
                .find(th => th.textContent.toLowerCase().includes(currentSort.column));
            if (activeHeader) {
                const text = activeHeader.textContent.replace(' ‚¨ÜÔ∏è', '').replace(' ‚¨áÔ∏è', '');
                activeHeader.textContent = text + (currentSort.ascending ? ' ‚¨ÜÔ∏è' : ' ‚¨áÔ∏è');
            }
        }
        
        const tbody = document.getElementById('rankingBody');
        // Mobile card container
        let rankingCardsContainer = document.getElementById('rankingCards');
        if (!rankingCardsContainer) {
            const container = document.createElement('div');
            container.id = 'rankingCards';
            container.className = 'ranking-cards';
            const table = document.querySelector('.ranking-table');
            table.parentNode.insertBefore(container, table.nextSibling);
            rankingCardsContainer = container;
        }


        
        if (totalBattles === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="no-battles">Start met battlen om je ranking te zien! üé¢</td></tr>';
            rankingCardsContainer.innerHTML = '';
            return;
        }

        // Build table rows and mobile cards
        const rowsHtml = [];
        const cardsHtml = [];

        sorted.forEach((coaster, index) => {
            const rank = index + 1;
            const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
            const winrate = coaster.battles > 0 ? ((coaster.wins / coaster.battles) * 100).toFixed(1) : '0.0';
            const escapedName = coaster.name.replace(/'/g, "\\'");

                const dataId = (coaster.name || '').replace(/"/g, '&quot;');
                rowsHtml.push(`
                    <tr data-id="${dataId}">
                        <td><span class="rank-medal">${medal}</span>${rank}</td>
                        <td><strong>${coaster.name}</strong></td>
                        <td>${coaster.park}</td>
                        <td>${coaster.manufacturer}</td>
                        <td><span class="elo-score">${Math.round(displayedRating(coaster))} ¬± ${Math.round(coaster.rd)}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.battles}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.wins}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.losses}</span></td>
                    </tr>
                `);

            // Card for mobile
            const rankBadgeClass = rank <= 3 ? 'rank-badge top-3' : 'rank-badge';
            cardsHtml.push(`
                <div class="ranking-card" data-rank="${rank}">
                    <div class="${rankBadgeClass}">${rank}</div>
                    <div class="ranking-left">
                        <div class="name">${coaster.name}</div>
                        <div class="meta">${coaster.park} ‚Ä¢ ${coaster.manufacturer} ‚Ä¢ <span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.wins}-${coaster.losses}</span></div>
                    </div>
                    <div class="ranking-right">
                            <div class="elo">${Math.round(displayedRating(coaster))}</div>
                        </div>
                </div>
            `);
        });

        tbody.innerHTML = rowsHtml.join('');
        rankingCardsContainer.innerHTML = cardsHtml.join('');
        
        // Match tab heights after content is rendered
        setTimeout(() => matchTabHeights(), 50);
    }

    function filterRanking() {
        const searchTerm = document.getElementById('searchBox').value.toLowerCase();
        const rows = document.querySelectorAll('#rankingBody tr');
        
        rows.forEach(row => {
            const text = row.textContent.toLowerCase();
            row.style.display = text.includes(searchTerm) ? '' : 'none';
        });
    }

    function viewCoasterHistory(coasterName) {
        // Switch to history tab
        switchTab('history');
        
        // Set the search box value to the coaster name
        const historySearch = document.getElementById('historySearch');
        const clearBtn = document.getElementById('clearHistorySearchBtn');
        historySearch.value = coasterName;
        clearBtn.style.display = 'block';
        
        // Mark as selected
        coasterSelected = true;
        
        // Trigger the search/filter
        displayHistory();
        updateHistoryFilterUI();
    }

    function resetRankingOnly() {
        if (!currentUser) return;
        
        // Show custom modal for ranking reset
        const modal = document.getElementById('resetRankingModal');
        const userName = currentUser === 'luca' ? 'Luca' : 'Wouter';
        document.getElementById('resetRankingUserName').textContent = userName;
        modal.classList.add('show');
    }

    function closeResetRankingModal() {
        const modal = document.getElementById('resetRankingModal');
        modal.classList.remove('show');
    }

    function confirmResetRanking() {
        closeResetRankingModal();
        
        // Reset only ranking and battle history, preserve achievements
        coasterStats = initializeStats();
        totalBattlesCount = 0;
        coasterHistory = [];
        completedPairs = new Set();
        
        // DO NOT reset achievements - they are preserved
        
        saveData();
        displayBattle();
        updateRanking();
        alert('Ranking is gereset! Achievements zijn behouden. üîÑ');
    }

    function resetAllData() {
        if (!currentUser) return;
        
        // Show custom modal for full reset
        const modal = document.getElementById('resetModal');
        const userName = currentUser === 'luca' ? 'Luca' : 'Wouter';
        document.getElementById('resetUserName').textContent = userName;
        modal.classList.add('show');
    }

    function closeResetModal() {
        const modal = document.getElementById('resetModal');
        modal.classList.remove('show');
    }

    function confirmReset() {
        closeResetModal();
        
        // Perform the full reset
        coasterStats = initializeStats();
        totalBattlesCount = 0;
        coasterHistory = [];
        completedPairs = new Set();
        
        // Reset achievements
        if (typeof achievementManager !== 'undefined') {
            achievementManager.unlockedAchievements.clear();
            achievementManager.leftStreak = 0;
            achievementManager.rightStreak = 0;
            achievementManager.perfectMatches = 0;
            achievementManager.closeFights = 0;
            achievementManager.sessionBattles = 0;
            achievementManager.lastBattleDate = null;
            achievementManager.consecutiveDays = 0;
            achievementManager.dailyBattleDates = new Set();
            achievementManager.save(currentUser);
            
            // Clear localStorage for achievements
            localStorage.removeItem(`achievements_${currentUser}`);
            localStorage.removeItem(`achievementStats_${currentUser}`);
        }
        
        saveData();
        displayBattle();
        updateRanking();
        updateAchievementsTab();
        alert('Alle data is gereset! üîÑ');
    }

    // Save user preference when switching (wrap original function)
    const originalSwitchUser = switchUser;
    switchUser = function(user) {
        originalSwitchUser(user);
        localStorage.setItem('lastUser', user);
    };

    // Creating a downloadable CSV of the current ranking
function downloadRankingCSV() {
    if (!currentUser) {
        alert('Select a user first!');
        return;
    }
    
    if (Object.keys(coasterStats).length === 0) {
        alert('Geen ranking data om te downloaden.');
        return;
    }
    
    // Sort by rating (same as default ranking view)
    const statsArray = Object.values(coasterStats);
    const sorted = [...statsArray].sort((a, b) => b.rating - a.rating);
    
    // Create CSV header
    let csv = 'Rank,Naam,Park,Fabrikant,Rating,RD,Volatility,Battles,Wins,Losses,Win%\n';
    
    // Add data rows
    sorted.forEach((coaster, index) => {
        const rank = index + 1;
        const winrate = coaster.battles > 0 ? ((coaster.wins / coaster.battles) * 100).toFixed(1) : '0.0';
        
        // Escape commas and quotes in text fields
        const escapeCsv = (text) => {
            if (typeof text !== 'string') return text;
            if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                return '"' + text.replace(/"/g, '""') + '"';
            }
            return text;
        };
        
        csv += `${rank},${escapeCsv(coaster.name)},${escapeCsv(coaster.park)},${escapeCsv(coaster.manufacturer)},${Math.round(coaster.rating)},${Math.round(coaster.rd)},${coaster.volatility.toFixed(6)},${coaster.battles},${coaster.wins},${coaster.losses},${winrate}\n`;
    });
    
    // Create download
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    link.href = url;
    link.download = `coaster_ranking_${currentUser}_${timestamp}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    showToast('‚úÖ CSV downloaded!');
}

// ============================================
// ACHIEVEMENTS SYSTEM INTEGRATION
// ============================================

// Gather current game statistics for achievement checking
function getGameStats() {
    const statsArray = Object.values(coasterStats);
    
    // Check if any coaster is ranked #1
    const sorted = [...statsArray].sort((a, b) => b.rating - a.rating);
    const hasTopRankedCoaster = sorted.length > 0;
    
    // Check if all coasters have minimum battles
    const allCoastersMinBattles = statsArray.length > 0 ? 
        Math.min(...statsArray.map(s => s.battles)) : 0;
    
    // Check if all pairs completed
    const allPairsCompleted = areAllPairsCompleted();
    
    // Get unique parks and manufacturers from battled coasters
    const battledCoasters = statsArray.filter(s => s.battles > 0);
    const uniqueParks = new Set(battledCoasters.map(s => s.park).filter(Boolean)).size;
    const uniqueManufacturers = new Set(battledCoasters.map(s => s.manufacturer).filter(Boolean)).size;
    
    return {
        totalBattles: totalBattlesCount,
        sessionBattles: achievementManager.sessionBattles,
        closeFights: achievementManager.closeFights,
        underdogWins: achievementManager.underdogWins,
        underdogWinStreak: achievementManager.underdogWinStreak,
        hasTopRankedCoaster,
        allCoastersMinBattles,
        allPairsCompleted,
        leftStreak: achievementManager.leftStreak,
        rightStreak: achievementManager.rightStreak,
        alternatingStreak: achievementManager.alternatingStreak,
        perfectMatches: achievementManager.perfectMatches,
        uniqueParks,
        uniqueManufacturers,
        consecutiveDays: achievementManager.consecutiveDays,
        siblingBattles: achievementManager.siblingBattles,
        usedKeyboard: achievementManager.usedKeyboard,
        usedNumberKeys: achievementManager.usedNumberKeys
    };
}

// Check for new achievements and show toasts
function checkAndShowAchievements() {
    if (!currentUser || typeof achievementManager === 'undefined') return;
    
    const stats = getGameStats();
    const newAchievements = achievementManager.checkAchievements(stats, currentUser);
    
    // Show toast for each new achievement with staggered timing
    newAchievements.forEach((achievement, index) => {
        setTimeout(() => {
            showAchievementToast(achievement);
        }, index * 600); // Stagger by 600ms
    });
    
    // Always update achievements tab display (not just when new achievements)
    updateAchievementsTab();
}

// Render the achievements tab
function updateAchievementsTab() {
    console.log('updateAchievementsTab called');
    console.log('achievementManager exists:', typeof achievementManager !== 'undefined');
    
    if (typeof achievementManager === 'undefined') {
        console.warn('achievementManager is undefined');
        return;
    }
    
    const grid = document.getElementById('achievementsGrid');
    const progressText = document.getElementById('achievementProgress');
    const progressPercentage = document.getElementById('achievementPercentage');
    const progressBar = document.getElementById('achievementProgressBar');
    const tabCounter = document.getElementById('achievementCount');
    
    if (!grid) {
        console.warn('achievementsGrid element not found');
        return;
    }
    
    const achievements = achievementManager.getAllAchievements();
    const unlockedCount = achievementManager.getUnlockedCount();
    const totalCount = achievementManager.getTotalCount();
    const percentage = Math.round((unlockedCount / totalCount) * 100);
    
    console.log('Updating achievements tab:', { unlockedCount, totalCount, percentage });
    
    // Update progress indicators
    if (progressText) progressText.textContent = `${unlockedCount} / ${totalCount}`;
    if (progressPercentage) progressPercentage.textContent = `(${percentage}%)`;
    if (progressBar) progressBar.style.width = `${percentage}%`;
    if (tabCounter) tabCounter.textContent = `${unlockedCount}/${totalCount}`;
    
    // Update filter counter
    const filterCounter = document.getElementById('achievementFilterCounter');
    if (filterCounter) filterCounter.textContent = `${unlockedCount}/${totalCount} unlocked`;
    
    // Render achievement cards
    grid.innerHTML = achievements.map(achievement => {
        const lockedClass = achievement.unlocked ? 'unlocked' : 'locked';
        const categoryClass = `category-${achievement.category || 'battles'}`;
        
        let dateHtml = '';
        if (achievement.unlocked && achievement.unlockedDate) {
            try {
                const date = new Date(achievement.unlockedDate);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                dateHtml = `<div class="achievement-date">Unlocked ${dateStr}</div>`;
            } catch (e) {
                // Ignore date formatting errors
            }
        }
        
        return `
            <div class="achievement-card ${lockedClass} ${categoryClass}" data-category="${achievement.category || 'battles'}">
                <div class="achievement-icon">${achievement.icon}</div>
                <div class="achievement-name">${achievement.name}</div>
                <div class="achievement-desc">${achievement.description}</div>
                ${dateHtml}
            </div>
        `;
    }).join('');
    
    console.log('Achievement cards rendered:', achievements.length);
}

// Filter achievements by category
function filterAchievements(category) {
    const grid = document.getElementById('achievementsGrid');
    if (!grid) return;
    
    const cards = grid.querySelectorAll('.achievement-card');
    const filterButtons = document.querySelectorAll('.filter-tag');
    
    // Update active state on filter buttons
    filterButtons.forEach(btn => {
        if (btn.dataset.category === category) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Show/hide cards based on filter
    cards.forEach(card => {
        if (category === 'all') {
            card.style.display = '';
        } else {
            const hasCategory = card.classList.contains(`category-${category}`);
            card.style.display = hasCategory ? '' : 'none';
        }
    });
    
    // Match tab heights after filtering
    setTimeout(() => matchTabHeights(), 50);
}
